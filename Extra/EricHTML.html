<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Use correct character set. -->
  <meta charset="utf-8">
  <!-- Tell IE to use the latest, best version. -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- Make the application on mobile take up the full browser screen and disable user scaling. -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <title>Eric Keilty Cesium</title>
  <script src="../Build/Cesium/Cesium.js"></script>
  <style>
      @import url(../Build/Cesium/Widgets/widgets.css);
      @import url(../templates/bucket.css);
      html, body, #cesiumContainer {
          width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
      }
      @import url(../templates/bucket.css);    #toolbar {        background: rgba(42, 42, 42, 0.8);        padding: 4px;        border-radius: 4px;    }    #toolbar input {        vertical-align: middle;        padding-top: 2px;        padding-bottom: 2px;    }    #toolbar table tr {        transform: translateY(0);        transition: transform 0.4s ease-out;    }    #toolbar table tr.up {        transform: translateY(33px);        transition: none;    }    #toolbar table tr.down {        transform: translateY(-33px);        transition: none;    }
  </style>
</head>
<body>
  <div id="cesiumContainer" class="fullSize"></div>  <div id="loadingOverlay"><h1>Loading...</h1></div>  <div id="toolbar">
  <table><tbody data-bind="foreach: layers">    <tr data-bind="css: { up: $parent.upLayer === $data, down: $parent.downLayer === $data }">        <td><input type="checkbox" data-bind="checked: show"></td>        <td>            <span data-bind="text: name, visible: !$parent.isSelectableLayer($data)"></span>            <select data-bind="visible: $parent.isSelectableLayer($data), options: $parent.baseLayers, optionsText: 'name', value: $parent.selectedLayer"></select>        </td>        <td>            <input type="range" min="0" max="1" step="0.01" data-bind="value: alpha, valueUpdate: 'input'">        </td>        <td><button type="button" class="cesium-button" data-bind="click: function() { $parent.raise($data, $index()); }, visible: $parent.canRaise($index())">▲</button></td>        <td><button type="button" class="cesium-button" data-bind="click: function() { $parent.lower($data, $index()); }, visible: $parent.canLower($index())">▼</button></td>    </tr>  </tbody></table>  </div>
  
  <script>
    //defining some variablesvar viewer = new Cesium.Viewer('cesiumContainer', {    baseLayerPicker : false,    selectionIndicator : true,    infoBox : true});var scene = viewer.scene;var handler;var numClicks = 0;var UserLatLong = [];var UserLat = [];var UserLon = [];//gets rid of that dumb double click actionviewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);var imageryLayers = viewer.imageryLayers;var viewModel = {    layers : [],    baseLayers : [],    upLayer : null,    downLayer : null,    selectedLayer : null,    isSelectableLayer : function(layer) {        return baseLayers.indexOf(layer) >= 0;    },    raise : function(layer, index) {        imageryLayers.raise(layer);        viewModel.upLayer = layer;        viewModel.downLayer = viewModel.layers[Math.max(0, index - 1)];        updateLayerList();        window.setTimeout(function() { viewModel.upLayer = viewModel.downLayer = null; }, 10);    },    lower : function(layer, index) {        imageryLayers.lower(layer);        viewModel.upLayer = viewModel.layers[Math.min(viewModel.layers.length - 1, index + 1)];        viewModel.downLayer = layer;        updateLayerList();        window.setTimeout(function() { viewModel.upLayer = viewModel.downLayer = null; }, 10);    },    canRaise : function(layerIndex) {        return layerIndex > 0;    },    canLower : function(layerIndex) {        return layerIndex >= 0 && layerIndex < imageryLayers.length - 1;    }};Cesium.knockout.track(viewModel);var baseLayers = viewModel.baseLayers;function setupLayers() {    // Create all the base layers that this example will support.    // These base layers aren't really special.  It's possible to have multiple of them    // enabled at once, just like the other layers, but it doesn't make much sense because    // all of these layers cover the entire globe and are opaque.    addBaseLayerOption(            'Bing Maps Aerial',            undefined); // the current base layer    // Create the additional layers    addAdditionalLayerOption(            'Western Gulf of Main',            new Cesium.ArcGisMapServerImageryProvider({                url : 'http://gis.ccom.unh.edu:6080/arcgis/rest/services/GulfOfMaine/WGOM_HiBathy_Hill_4m/MapServer'            }));    /*    addAdditionalLayerOption(            'Name',            new Cesium.ArcGisMapServerImageryProvider({                url : 'url'            }));            */}function addBaseLayerOption(name, imageryProvider) {    var layer;    if (typeof imageryProvider === 'undefined') {        layer = imageryLayers.get(0);        viewModel.selectedLayer = layer;    } else {        layer = new Cesium.ImageryLayer(imageryProvider);    }    layer.name = name;    baseLayers.push(layer);}function addAdditionalLayerOption(name, imageryProvider, alpha, show) {    var layer = imageryLayers.addImageryProvider(imageryProvider);    layer.alpha = Cesium.defaultValue(alpha, 0.5);    layer.show = Cesium.defaultValue(show, true);    layer.name = name;    Cesium.knockout.track(layer, ['alpha', 'show', 'name']);}function updateLayerList() {    var numLayers = imageryLayers.length;    viewModel.layers.splice(0, viewModel.layers.length);    for (var i = numLayers - 1; i >= 0; --i) {        viewModel.layers.push(imageryLayers.get(i));    }}setupLayers();updateLayerList();//Bind the viewModel to the DOM elements of the UI that call for it.var toolbar = document.getElementById('toolbar');Cesium.knockout.applyBindings(viewModel, toolbar);Cesium.knockout.getObservable(viewModel, 'selectedLayer').subscribe(function(baseLayer) {    // Handle changes to the drop-down base layer selector.    var activeLayerIndex = 0;    var numLayers = viewModel.layers.length;    for (var i = 0; i < numLayers; ++i) {        if (viewModel.isSelectableLayer(viewModel.layers[i])) {            activeLayerIndex = i;            break;        }    }    var activeLayer = viewModel.layers[activeLayerIndex];    var show = activeLayer.show;    var alpha = activeLayer.alpha;    imageryLayers.remove(activeLayer, false);    imageryLayers.add(baseLayer, numLayers - activeLayerIndex - 1);    baseLayer.show = show;    baseLayer.alpha = alpha;    updateLayerList();});//Degrees to UTM Functionfunction deg2utm(Lat, Lon) {    var n1 = Lat.length;    var n2 = Lon.length;        if (n1 !== n2) {        alert("Lat and Lon vectors should have the same length");    }        var sa = 6378137.000000;    var sb = 6356752.314245;        var e2 = ( Math.sqrt(((sa*sa) - (sb*sb))) ) / sb;    var e2cuadrada = e2 * e2;    var c = (sa*sa) / sb;            var lat = [Lat[0] * Math.PI/180]; //converting to radians    var lon = [Lon[0] * Math.PI/180]; //so they can be used in trig functions    for (var i=1; i<Lat.length; i++) {        lat.push(Lat[i] * Math.PI/180);        lon.push(Lon[i] * Math.PI/180);    }            var Huso = [Math.floor( ( Lon[0] / 6 ) + 31)];    var S = [( Huso[0] * 6 ) - 183];    var deltaS = [lon[0] - S[0]*Math.PI/180];    for (var i=1; i<Lon.length; i++) {        Huso.push(Math.floor( ( Lon[i] / 6 ) + 31));        S.push(( ( Huso[i] * 6 ) - 183 ));        deltaS.push(lon[i] - S[i]*Math.PI/180) ;    }            var Letra;    if (Lat[0] < -72) {            Letra = 'C';        } else if (Lat[0] < -64) {            Letra = 'D';        } else if (Lat[0] < -56) {            Letra = 'E';        } else if (Lat[0] < -48) {            Letra = 'F';        } else if (Lat[0] < -40) {            Letra = 'G';        } else if (Lat[0] < -32) {            Letra = 'H';        } else if (Lat[0] < -24) {            Letra = 'J';        } else if (Lat[0] < -16) {            Letra = 'K';        } else if (Lat[0] < -8) {            Letra = 'L';        } else if (Lat[0] < 0) {            Letra = 'M';        } else if (Lat[0] < 8) {            Letra = 'N';        } else if (Lat[0] < 16) {            Letra = 'P';        } else if (Lat[0] < 24) {            Letra = 'Q';        } else if (Lat[0] < 32) {            Letra = 'R';        } else if (Lat[0] < 40) {            Letra = 'S';        } else if (Lat[0] < 48) {            Letra = 'T';        } else if (Lat[0] < 56) {            Letra = 'U';        } else if (Lat[0] < 64) {            Letra = 'V';        } else if (Lat[0] < 72) {            Letra = 'W';        }else{            Letra = 'X';        }        var utmzone_string = String(Huso[0]) + " " + String(Letra);    var utmzone_M = [utmzone_string];        for (var i=1; i<Lat.length; i++) {            if (Lat[i] < -72) {            Letra = 'C';        } else if (Lat[i] < -64) {            Letra = 'D';        } else if (Lat[i] < -56) {            Letra = 'E';        } else if (Lat[i] < -48) {            Letra = 'F';        } else if (Lat[i] < -40) {            Letra = 'G';        } else if (Lat[i] < -32) {            Letra = 'H';        } else if (Lat[i] < -24) {            Letra = 'J';        } else if (Lat[i] < -16) {            Letra = 'K';        } else if (Lat[i] < -8) {            Letra = 'L';        } else if (Lat[i] < 0) {            Letra = 'M';        } else if (Lat[i] < 8) {            Letra = 'N';        } else if (Lat[i] < 16) {            Letra = 'P';        } else if (Lat[i] < 24) {            Letra = 'Q';        } else if (Lat[i] < 32) {            Letra = 'R';        } else if (Lat[i] < 40) {            Letra = 'S';        } else if (Lat[i] < 48) {            Letra = 'T';        } else if (Lat[i] < 56) {            Letra = 'U';        } else if (Lat[i] < 64) {            Letra = 'V';        } else if (Lat[i] < 72) {            Letra = 'W';        }else{            Letra = 'X';        }                utmzone_string =  String(Huso[i]) + " " + String(Letra);        utmzone_M.push(utmzone_string);    }         var a = Math.cos(lat[0]) * Math.sin(deltaS[0]);    var epsilon = 0.5 * Math.log( ( 1 +  a) / ( 1 - a ) );    var nu = Math.atan( Math.tan(lat[0]) / Math.cos(deltaS[0]) ) - lat[0];    var v = ( c / Math.sqrt( ( 1 + ( e2cuadrada * ( Math.cos(lat[0]) ) * ( Math.cos(lat[0]) ) ) ) ) ) * 0.9996;    var ta = ( e2cuadrada / 2 ) * epsilon * epsilon * ( Math.cos(lat[0]) ) * ( Math.cos(lat[0]) );    var a1 = Math.sin( 2 * lat[0] );    var a2 = a1 * ( Math.cos(lat[0]) ) * (Math.cos(lat[0]) );    var j2 = lat[0] + ( a1 / 2 );    var j4 = ( ( 3 * j2 ) + a2 ) / 4;    var j6 = ( ( 5 * j4 ) + ( a2 * ( Math.cos(lat[0]) ) * ( Math.cos(lat[0]) ) ) ) / 3;    var alfa = ( 3 / 4 ) * e2cuadrada;    var beta = ( 5 / 3 ) * alfa * alfa;    var gama = ( 35 / 27 ) * alfa * alfa * alfa;    var Bm = 0.9996 * c * ( lat[0] - alfa * j2 + beta * j4 - gama * j6 );    var xx = [epsilon * v * ( 1 + ( ta / 3 ) ) + 500000];    var yy = [nu * v * ( 1 + ta ) + Bm];    for (var i=1; i<Huso.length; i++) {        a = Math.cos(lat[i]) * Math.sin(deltaS[i]);        epsilon = 0.5 * Math.log( ( 1 +  a) / ( 1 - a ) );        nu = Math.atan( Math.tan(lat[i]) / Math.cos(deltaS[i]) ) - lat[i];        v = ( c / Math.sqrt( ( 1 + ( e2cuadrada * ( Math.cos(lat[i]) ) * ( Math.cos(lat[i]) ) ) ) ) ) * 0.9996;        ta = ( e2cuadrada / 2 ) * epsilon * epsilon * ( Math.cos(lat[i]) ) * ( Math.cos(lat[i]) );        a1 = Math.sin( 2 * lat[i] );        a2 = a1 * ( Math.cos(lat[i]) ) * ( Math.cos(lat[i]) );        j2 = lat[i] + ( a1 / 2 );        j4 = ( ( 3 * j2 ) + a2 ) / 4;        j6 = ( ( 5 * j4 ) + ( a2 * ( Math.cos(lat[i]) ) * ( Math.cos(lat[i]) )) ) / 3;        alfa = ( 3 / 4 ) * e2cuadrada;        beta = ( 5 / 3 ) * alfa * alfa;        gama = ( 35 / 27 ) * alfa * alfa * alfa;        Bm = 0.9996 * c * ( lat[i] - alfa * j2 + beta * j4 - gama * j6 );        xx.push(epsilon * v * ( 1 + ( ta / 3 ) ) + 500000);        yy.push(nu * v * ( 1 + ta ) + Bm);    }                for (var i = 0; i<yy.length; i++) {        if (yy[i] < 0) {            yy[i] += 9999999;        }    }        var return_array = [xx, yy, utmzone_M];        return return_array;}//  _________________// |                 |// |                 |// | End of Function |// |                 |// |_________________|////UTM to Degrees Functionfunction utm2deg(xx, yy, utmzone) {        var n1 = xx.length;    var n2 = yy.length;    var n3 = utmzone.length;        if (n1 != n2 || n1 != n3) {        alert("x,y and utmzone vectors should have the same number or rows");    }           var sa = 6378137.000000;    var sb = 6356752.314245;        var e2 = ( Math.sqrt(((sa*sa) - (sb*sb))) ) / sb;    var e2cuadrada = e2 * e2;    var c = (sa*sa) / sb;       var Lat = [];    var Lon = [];    var hemis;    for (var i=0; i<n1; i++) {            if (utmzone[i][3] > 'X' || utmzone[i][3] < 'C') {            alert(" Warning utmzone should be a vector of strings like '30 T', not '30 t'");        }                if (utmzone[i][3] > 'M') {            hemis = 'N';        } else {            hemis = 'S';        }                var x = xx[i];        var y = yy[i];        var zone = parseInt(utmzone[i]);                var X = x - 500000;        var Y;        if (hemis == 'S' || hemis == 's') {            Y = y - 10000000;        } else {            Y = y;        }                        var S = ( ( zone * 6 ) - 183 );         var lat =  Y / ( 6366197.724 * 0.9996 );                                            var v = ( c / Math.sqrt( ( 1 + ( e2cuadrada * ( Math.cos(lat) ) * ( Math.cos(lat) ) ) ) ) ) * 0.9996;        var a = X / v;        var a1 = Math.sin( 2 * lat );        var a2 = a1 * ( Math.cos(lat) ) * ( Math.cos(lat) );        var j2 = lat + ( a1 / 2 );        var j4 = ( ( 3 * j2 ) + a2 ) / 4;        var j6 = ( ( 5 * j4 ) + ( a2 * ( Math.cos(lat) ) * ( Math.cos(lat) ) ) ) / 3;        var alfa = ( 3 / 4 ) * e2cuadrada;        var beta = ( 5 / 3 ) * alfa * alfa;        var gama = ( 35 / 27 ) * alfa * alfa * alfa;        var Bm = 0.9996 * c * ( lat - alfa * j2 + beta * j4 - gama * j6 );        var b = ( Y - Bm ) / v;        var Epsi = ( ( e2cuadrada * a * a ) / 2 ) * ( Math.cos(lat) ) * ( Math.cos(lat) );        var Eps = a * ( 1 - ( Epsi / 3 ) );        var nab = ( b * ( 1 - Epsi ) ) + lat;        var senoheps = ( Math.exp(Eps) - Math.exp(-Eps) ) / 2;        var Delt = Math.atan(senoheps / (Math.cos(nab) ) );        var TaO = Math.atan(Math.cos(Delt) * Math.tan(nab));        var longitude = (Delt *(180 / Math.PI ) ) + S;        var latitude = ( lat + ( 1 + e2cuadrada* (Math.cos(lat)^ 2) - ( 3 / 2 ) * e2cuadrada * Math.sin(lat) * Math.cos(lat) * ( TaO - lat ) ) * ( TaO - lat ) ) * (180 / Math.PI);                if (Lat.length == NaN) {            Lat = [latitude];            Lon = [longitude];        } else {            Lat.push(latitude);            Lon.push(longitude);        }    }        var return_array = [Lat, Lon];        return return_array;}//  _________________// |                 |// |                 |// | End of Function |// |                 |// |_________________|////Takes utm coordinates and outputs them all in the same UTM zonefunction utm_zone_mod(Coordinates) {        //var UTM = [C, D, E, F,                //G, H, J, K,                //L, M,               //N, P, Q, R,                //S, T, U, V,               //W, X];        //UTM zone dimensions do not change as you go east and west, just north and south        var UTMx = [206937.60462677642, 206937.60462677642, 293479.209076416, 374235.6942969916,                 447635.4254352151, 512260.8630573689, 566880.8754548477, 610457.9933552117,                 642176.4647191482, 661445.6151970772,                 667908.4673279062, //equator                661445.6151970772, 642176.4647191482, 610457.9933552117, 566880.8754548477,                512260.8630573689, 447635.4254352151, 374235.6942969916, 293479.209076416,                206937.60462677642];      var UTMy = [2009810.8648844596, 892266.3024614088, 891282.1534345208, 890124.1190612282,                888887.2829307698, 887665.3293948119, 886552.5277786559, 885634.1797139486,                884980.2887697788, 884640.4835743447, //equator                884640.4835743447, 884980.2887697788, 885634.1797139486, 886552.5277786559,                887665.3293948119, 888887.2829307698, 890124.1190612282, 891282.1534345208,                892266.3024614088, 2009810.8648844596];        var utm_letter_positions = {};        utm_letter_positions["C"] = 0;        utm_letter_positions["D"] = 1;        utm_letter_positions["E"] = 2;        utm_letter_positions["F"] = 3;        utm_letter_positions["G"] = 4;        utm_letter_positions["H"] = 5;        utm_letter_positions["J"] = 6;        utm_letter_positions["K"] = 7;        utm_letter_positions["L"] = 8;        utm_letter_positions["M"] = 9;        utm_letter_positions["N"] = 10;        utm_letter_positions["P"] = 11;        utm_letter_positions["Q"] = 12;        utm_letter_positions["R"] = 13;        utm_letter_positions["S"] = 14;        utm_letter_positions["T"] = 15;        utm_letter_positions["U"] = 16;        utm_letter_positions["V"] = 17;        utm_letter_positions["W"] = 18;        utm_letter_positions["X"] = 19;        function countInArray(array, what) {        var count = 0;        for (var i = 0; i < array.length; i++) {            if (array[i] === what) {                count++;            }        }        return count;    }        function ref_zone(utm_zone) {               //This loops through all the utm zones of the coordinates        //and adds only unique zones to the results array        //meaning it gets rid of any repeats        var results = [];        for (var i = 0; i < utm_zone.length - 1; i++) {            if (utm_zone[i + 1] == utm_zone[i] && countInArray(utm_zone[i], results) == 0) {                results.push(utm_zone[i]);            }        }                //figurese out which utm zone to use as a reference zone        var reference_utm;        var most_repeats = 0;        if (results.length == 0) {            return [utm_zone[0], 0]; //if there are no repeats, just return the first coordinate        } else {            for (var i=0; i<utm_zone.length; i++) {                //finds the utm zone that repeats the most                var repeats = countInArray(utm_zone, results[i]);                if (repeats >= utm_zone.length/2) {                    reference_utm = results[i];                    most_repeats = repeats;                    break;                } else if (repeats > most_repeats) {                    reference_utm = results[i];                    most_repeats = repeats;                }            }            return [reference_utm, most_repeats];        }    }        //finds the change in easting between the reference zone and utm zone of the coordinate    function dx(xi, xf, ref_zone) {        var negative;        if (xi == xf) {            return 0;        } else if (xi < xf) {            negative = 1;        } else {            negative = -1;        }                //the x coordinate is only dependent on its orientation in the y direction        var difference = Math.abs(xi - xf) * UTMx[utm_letter_positions[ref_zone]];        return difference * negative;    }        //finds the change in northing between the reference zone and utm zone of the coordinate    function dy(yi0, yf0) {        var yi;        var yf;        var negative;        if (yi0 == yf0) {            return 0;        } else if (yi0 < yf0) {            yi = yi0;            yf = yf0;            negative = 1;        } else {            yi = yf0;            yf = yi0;            negative = -1        }                var difference = 0;        for (var i = yi; i < yf; i++) {            difference += UTMy[utm_letter_positions[i]];        }        return difference * negative;    }            var x = Coordinates[0];    var y = Coordinates[1];    var utm = Coordinates[2];    var x_modify = [];    var y_modify = [];    var utm_modify = [];        var zone = ref_zone(utm)[0];        //for consistancy in string length, if the zone number is less than 10 it adds a zero in front    //7T --> 07T    if (parseInt(zone[0] + zone[1]) < 10) {        zone = "0" + zone;    }        //This finally loops through the coordiantes and changes the utm zone of the coordinates to the reference zone    for (var i = 0; i < utm.length; i++) {        if (utm[i] == zone) {            x_modify.push(x[i]);            y_modify.push(y[i]);            utm_modify.push(utm[i]);        } else {            x_modify.push(x[i] + dx(parseInt(zone[0] + zone[1]), parseInt(utm[i][0] + utm[i][1]), zone[3]));            y_modify.push(y[i] + dy(zone[3], utm[i][3]));            utm_modify.push(zone);        }    }        return [x_modify, y_modify, utm_modify];}//Makes string that we export to the textfilefunction outStringLatLong(LatArray, LonArray) {            if (UserLat == null) {        return "";    }else {        var LatLongString = "DEGREE\r\n" + "Latitude\tLongitude\r\n";        for (var i = 0; i < LatArray.length; i++) {            LatLongString += LatArray[i] + "\t\t" + LonArray[i] + "\r\n";        }        var UserUTM = deg2utm(LatArray, LonArray);        LatLongString += "\r\nUTM\r\n" + "Easting\t\t\tNorthing\t\tUTM Zone\r\n";        for (var i = 0; i < UserUTM[0].length; i++) {            if (parseInt(UserUTM[2][i][0] + UserUTM[2][i][1]) < 10) {                LatLongString += UserUTM[0][i] + "\t" + UserUTM[1][i] + "\t0" + UserUTM[2][i] + "\r\n";                //                Easting                 Northing                 Zone            } else {                LatLongString += UserUTM[0][i] + "\t" + UserUTM[1][i] + "\t" + UserUTM[2][i] + "\r\n";                //                 Easting                 Northing                 Zone            }                    }        var ModUTM = utm_zone_mod(UserUTM);        LatLongString += "\r\nMODIFIED UTM\r\n" + "Easting\t\t\tNorthing\t\tUTM Zone\r\n";        for (var i = 0; i < ModUTM[0].length; i++) {            LatLongString += ModUTM[0][i] + "\t" + ModUTM[1][i] + "\t" + ModUTM[2][i] + "\r\n";        }                LatLongString += "\r\n*Warning: Modified UTM are subject to large error*";                return LatLongString;    }}//This creates a file that the user can download locally function download(strData, strFileName, strMimeType) {    var D = document,        A = arguments,        a = D.createElement("a"),        d = A[0],        n = A[1],        t = A[2] || "text/plain";    //build download link:    a.href = "data:" + strMimeType + "charset=utf-8," + escape(strData);    if (window.MSBlobBuilder) { // IE10        var bb = new MSBlobBuilder();        bb.append(strData);        return navigator.msSaveBlob(bb, strFileName);    } /* end if(window.MSBlobBuilder) */    if ('download' in a) { //FF20, CH19        a.setAttribute("download", n);        a.innerHTML = "downloading...";        D.body.appendChild(a);        setTimeout(function() {            var e = D.createEvent("MouseEvents");            e.initMouseEvent("click", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);            a.dispatchEvent(e);            D.body.removeChild(a);        }, 66);        return true;    }; // end if('download' in a)    //do iframe dataURL download: (older W3)    var f = D.createElement("iframe");    D.body.appendChild(f);    f.src = "data:" + (A[2] ? A[2] : "application/octet-stream") + (window.btoa ? ";base64" : "") + "," + (window.btoa ? window.btoa : escape)(strData);    setTimeout(function() {        D.body.removeChild(f);    }, 333);    return true;}//  _____________________// |                     |// |    DO NOT TOUCH     |// |      ANYTHING       |// |     ABOVE THIS      |// |        POINT        |// |_____________________|////Function that creates actual Way Pointsfunction getLatLong_Points(e){        var mousePosition = new Cesium.Cartesian2(e.clientX, e.clientY);    var ellipsoid = viewer.scene.globe.ellipsoid;    var cartesian = viewer.camera.pickEllipsoid(mousePosition, ellipsoid);    if (cartesian) {        var cartographic = ellipsoid.cartesianToCartographic(cartesian);        var longitudeString = Cesium.Math.toDegrees(cartographic.longitude);        var latitudeString = Cesium.Math.toDegrees(cartographic.latitude);                //Cesium takes coordinates longitude, latitude instead of latitude, longitude        UserLatLong.push(longitudeString);        UserLatLong.push(latitudeString);                UserLat.push(latitudeString);        UserLon.push(longitudeString);                ++numClicks;                //Creating the Points        var point = viewer.entities.add({            name : 'Way Point ' + numClicks.toString(),            position : Cesium.Cartesian3.fromDegrees(parseFloat(UserLatLong[(2*numClicks)-2]), parseFloat(UserLatLong[(2*numClicks)-1])),            point : {                pixelSize : 10,                color : Cesium.Color.RED            }        });        point.description = UserLatLong[(2*numClicks)-1] + ', ' + UserLatLong[(2*numClicks)-2];            } else {        //If you want something to happened when the user clicks outside the globe        //put it here    }}//Function that makes a polygon in real time from Way Pointsfunction getLatLong_Polygon(e){        //Creating the Polygon    var polygon = viewer.entities.add({        name : 'Polygon',        polygon : {            hierarchy : Cesium.Cartesian3.fromDegreesArray(UserLatLong),            height : 0,            material : Cesium.Color.YELLOW.withAlpha(0.5),            outline : true,            outlineWidth : 3,            outlineColor : Cesium.Color.BLACK        }      });}var LatValue;var LongValue;var buttonValue;var buttonValue2;var StartLat;var StartLong;var Range;var Bearing;var EndLat;var EndLong;var Distance;var Number;var line;var endPoint;//adds an event listener for any button pressviewer.infoBox.frame.addEventListener('load', function() {    viewer.infoBox.frame.contentDocument.body.addEventListener('click', function(e) {        var entity = viewer.selectedEntity;        //if the button is pressed, do this        if (e.target && e.target.className === 'click-test-button') {            LatValue = viewer.infoBox.frame.contentDocument.getElementsByName("Latitude")[0].value;            LongValue = viewer.infoBox.frame.contentDocument.getElementsByName("Longitude")[0].value;            buttonValue = viewer.infoBox.frame.contentDocument.getElementsByClassName("click-test-button")[0].value;            //make sure the inputted coordinates are in the correct domain            if (LatValue < -90 || LatValue > 90 || LongValue < -180 || LongValue > 180) {                alert("Point is out of range");            } else if (LatValue == "") {                alert("Latitude value is not filled in");            } else if (LongValue == "") {                alert("Longitude value is not filled in");            } else {                //make a new point with updated coordinates                var point = viewer.entities.add({                    name : "Way Point " + buttonValue,                    position : Cesium.Cartesian3.fromDegrees(LongValue, LatValue),                    point : {                        pixelSize : 10,                        color : Cesium.Color.RED                    }                });                point.description = LatValue.toString() + ', ' + LongValue.toString();                                //refedining arrays with latitude, longitude coordinates once a point was changed                UserLat[parseInt(buttonValue)-1] = LatValue;                UserLon[parseInt(buttonValue)-1] = LongValue;                UserLatLong[(2*parseInt(buttonValue))-1] = LatValue;                UserLatLong[(2*parseInt(buttonValue))-2] = LongValue;                                //delete old point                entity = viewer.selectedEntity;                viewer.entities.remove(entity);            }        //if a different button is pressed, do this        } else if (e.target && e.target.className === 'swap-start-end') {                        StartLat = viewer.infoBox.frame.contentDocument.getElementsByName("S-Latitude")[0].value;            StartLong = viewer.infoBox.frame.contentDocument.getElementsByName("S-Longitude")[0].value;            Range = viewer.infoBox.frame.contentDocument.getElementsByName("Range")[0].value;            Bearing = viewer.infoBox.frame.contentDocument.getElementsByName("Bearing")[0].value;            EndLat = viewer.infoBox.frame.contentDocument.getElementsByName("E-Latitude")[0].value;            EndLong = viewer.infoBox.frame.contentDocument.getElementsByName("E-Longitude")[0].value;                        //some error stuff            if (StartLat == "" || StartLong == "") {                alert("Starting Latitude and Longitude are undefined");            }else if (EndLat == "" || EndLong == "") {                alert("Ending Latitude and Longitude are undefined");            }else if(StartLat < -90 || StartLat > 90 || StartLong < -180 || StartLong > 180) {                alert("Starting Latitude and Longitude are out of range");            }else if(EndLat < -90 || EndLat > 90 || EndLong < -180 || EndLong > 180) {                alert("Starting Latitude and Longitude are out of range");            } else {                //actually coding the button's function                viewer.infoBox.frame.contentDocument.getElementsByName("E-Latitude")[0].value = StartLat;                viewer.infoBox.frame.contentDocument.getElementsByName("E-Longitude")[0].value = StartLong;                viewer.infoBox.frame.contentDocument.getElementsByName("S-Latitude")[0].value = EndLat;                viewer.infoBox.frame.contentDocument.getElementsByName("S-Longitude")[0].value = EndLong;                                if (Range != "" && Bearing != "") {                    //update the range and bearing                                        //The Range will not change                    //The Bearing will be rotated 180 Degrees                    var toR = Math.PI/180;                    var x = Math.cos(StartLat*toR)*Math.sin(StartLong*toR-EndLong*toR);                    var y = Math.cos(EndLat*toR)*Math.sin(StartLat*toR) - Math.sin(EndLat*toR)*Math.cos(StartLat*toR)*Math.cos(StartLong*toR-EndLong*toR);                    Bearing = Math.atan2(x,y);                    Bearing *= 180/Math.PI;                    if (Bearing < 0) {                        Bearing += 360;                    } else if (Bearing == 360){                        Bearing = 0;                    }                    viewer.infoBox.frame.contentDocument.getElementsByName("Bearing")[0].value = Bearing;                }            }                        } else if (e.target && e.target.className === 'Fill-in') {                        StartLat = viewer.infoBox.frame.contentDocument.getElementsByName("S-Latitude")[0].value;            StartLong = viewer.infoBox.frame.contentDocument.getElementsByName("S-Longitude")[0].value;            Range = viewer.infoBox.frame.contentDocument.getElementsByName("Range")[0].value;            Bearing = viewer.infoBox.frame.contentDocument.getElementsByName("Bearing")[0].value;            EndLat = viewer.infoBox.frame.contentDocument.getElementsByName("E-Latitude")[0].value;            EndLong = viewer.infoBox.frame.contentDocument.getElementsByName("E-Longitude")[0].value;            buttonValue = viewer.infoBox.frame.contentDocument.getElementsByClassName("Fill-in")[0].value;                        if (Bearing != "" && !isNaN(Bearing)) {                Bearing = parseFloat(Bearing);                while (Bearing > 360) {                    Bearing -= 360;                }                while (Bearing < 0) {                    Bearing += 360                }            }                        var all_fields = false;            //some error stuff at the begining            if (isNaN(StartLat)) {                alert("Starting Latitude is not a numerical input");            } else if (isNaN(StartLong)) {                alert("Starting Longitude is not a numerical input");            } else if (isNaN(Range)) {                alert("The Range is not a numerical input");            } else if (isNaN(Bearing)) {                alert("The Bearing is not a numerical input");            } else if (isNaN(EndLat)) {                alert("Ending Latitude is not a numerical input");            } else if (isNaN(EndLong)) {                alert("Ending Longitude is not a numerical input");            } else if (StartLat != "" && StartLong != "" && Range != "" && Bearing != "" && EndLat != "" && EndLong != "") {                //if all fields are fill                all_fields = true;                alert("all fields are filled, delete what you want to be filled in");            } else if (StartLat != "" && StartLong != "" && Range == "" && Bearing == "" && EndLat != "" && EndLong != "") {                //if only Starting and Ending Latitudes and Longitudes are filled                                //getting Range (in meters)                var positions = Cesium.Cartesian3.fromDegreesArray([StartLong, StartLat, EndLong, EndLat]);                var surfacePositions = Cesium.PolylinePipeline.generateArc({                    positions: positions                });                                var scratchCartesian3 = new Cesium.Cartesian3();                var surfacePositionsLength = surfacePositions.length;                Range = 0;                for (var i = 3; i < surfacePositionsLength; i += 3) {                    scratchCartesian3.x = surfacePositions[i] - surfacePositions[i - 3];                    scratchCartesian3.y = surfacePositions[i + 1] - surfacePositions[i - 2];                    scratchCartesian3.z = surfacePositions[i + 2] - surfacePositions[i - 1];                    Range += Cesium.Cartesian3.magnitude(scratchCartesian3);                }                                //getting Bearing                var toR = Math.PI/180;                var x = Math.cos(EndLat*toR)*Math.sin(EndLong*toR-StartLong*toR);                var y = Math.cos(StartLat*toR)*Math.sin(EndLat*toR) - Math.sin(StartLat*toR)*Math.cos(EndLat*toR)*Math.cos(EndLong*toR-StartLong*toR);                Bearing = Math.atan2(x,y);                Bearing *= 180/Math.PI;                if (Bearing < 0) {                    Bearing += 360;                } else if (Bearing == 360){                    Bearing = 0;                }                            } else if (StartLat != "" && StartLong != "" && Range != "" && Bearing != "" && EndLat == "" && EndLong == "") {                //if only the Starting Latitude and Longitude and the Range and Bearing is filled                //                //This is wicked inacurrate                //                var R = 6371010; //in meters                var distRatio = Range / R;                var distRatioSine = Math.sin(distRatio);                var distRatioCosine = Math.cos(distRatio);                var startLatRad = StartLat*(Math.PI/180);                var startLonRad = StartLong*(Math.PI/180);                var startLatCos = Math.cos(startLatRad);                var startLatSin = Math.sin(startLatRad);                var endLatRads = Math.asin((startLatSin * distRatioCosine) + (startLatCos * distRatioSine * Math.cos(Bearing*(Math.PI/180))));                                var x = Math.sin(Bearing*(Math.PI/180)) * distRatioSine * startLatCos;                var y = distRatioCosine - startLatSin * Math.sin(endLatRads);                var endLonRads = startLonRad + Math.atan2(x, y);                                EndLat = endLatRads*(180/Math.PI);                EndLong = endLonRads*(180/Math.PI);                            } else if (StartLat == "" && StartLong == "" && Range != "" && Bearing != "" && EndLat != "" && EndLong != "") {                //if only the Ending Latitude and Longitude and the Range and Bearing is filled            }else {                alert("not enough information");            }                        if (!all_fields) {                                //updating the Starting point incase it was changed                entity.position = Cesium.Cartesian3.fromDegrees(StartLong, StartLat);                //Creating end point                endPoint = viewer.entities.add({                    name : "End Way Point " + buttonValue,                    position : Cesium.Cartesian3.fromDegrees(EndLong, EndLat),                    point : {                        pixelSize : 10,                        color : Cesium.Color.BLACK                    }                });                //Creating connecting line                line = viewer.entities.add({                    name : "Line " + buttonValue,                    polyline : {                         positions : Cesium.Cartesian3.fromDegreesArray([StartLong, StartLat, EndLong, EndLat]),                         width : 3,                         material : Cesium.Color.BLUE                    }                });                //adding the start and end lat/lon values to the arrays                UserLat[(2*parseInt(buttonValue))-2] = StartLat;                UserLon[(2*parseInt(buttonValue))-2] = StartLong;                UserLat[(2*parseInt(buttonValue))-1] = EndLat;                UserLon[(2*parseInt(buttonValue))-1] = EndLong;                UserLatLong[(4*parseInt(buttonValue))-3] = StartLat;                UserLatLong[(4*parseInt(buttonValue))-4] = StartLong;                UserLatLong[(4*parseInt(buttonValue))-1] = EndLat;                UserLatLong[(4*parseInt(buttonValue))-2] = EndLong;                //update all the textboxes                viewer.infoBox.frame.contentDocument.getElementsByName("S-Latitude")[0].value = StartLat;                viewer.infoBox.frame.contentDocument.getElementsByName("S-Longitude")[0].value = StartLong;                viewer.infoBox.frame.contentDocument.getElementsByName("Range")[0].value = Range;                viewer.infoBox.frame.contentDocument.getElementsByName("Bearing")[0].value = Bearing;                viewer.infoBox.frame.contentDocument.getElementsByName("E-Latitude")[0].value = EndLat;                viewer.infoBox.frame.contentDocument.getElementsByName("E-Longitude")[0].value = EndLong;                //updating numClicks will account for the buttonValue                numClicks = UserLat.length;                entity.description = '' +                'Start Latitude: <input type="text" name="S-Latitude" id="S-Latitude" value="' + StartLat + '">[-90, 90]<br>\                Start Longitude: <input type="text" name="S-Longitude" id="S-Longitude" value="' + StartLong + '">[-180, 180]<br>\                Range: <input type="text" name="Range" id="Range" value="' + Range + '">m<br>\                Bearing: <input type="text" name="Bearing" id="Bearing" value="' + Bearing + '">Degrees<br>\                End Latitude: <input type="text" name="E-Latitude" id="E-Latitude" value="' + EndLat + '">[-90, 90]<br>\                End Longitude: <input type="text" name="E-Longitude" id="E-Longitude" value="' + EndLong + '">[-180, 180]<br>\                <div style="padding:15px"><button class="swap-start-end">Swap Start/End</button></div>\                <div style="padding:15px"><button class="Fill-in" value="' + buttonValue + '">Fill In</button></div>';            }                    } else if (e.target && e.target.className === 'Fill-in2') {            StartLat = viewer.infoBox.frame.contentDocument.getElementsByName("S-Latitude")[0].value;            StartLong = viewer.infoBox.frame.contentDocument.getElementsByName("S-Longitude")[0].value;            Range = viewer.infoBox.frame.contentDocument.getElementsByName("Range")[0].value;            Bearing = viewer.infoBox.frame.contentDocument.getElementsByName("Bearing")[0].value;            EndLat = viewer.infoBox.frame.contentDocument.getElementsByName("E-Latitude")[0].value;            EndLong = viewer.infoBox.frame.contentDocument.getElementsByName("E-Longitude")[0].value;            buttonValue2 = viewer.infoBox.frame.contentDocument.getElementsByClassName("Fill-in2")[0].value;            Number = viewer.infoBox.frame.contentDocument.getElementsByName("Number")[0].value;            Distance = viewer.infoBox.frame.contentDocument.getElementsByName("Distance")[0].value;                        if (Bearing != "" && !isNaN(Bearing)) {                Bearing = parseFloat(Bearing);                while (Bearing > 360) {                    Bearing -= 360;                }                while (Bearing < 0) {                    Bearing += 360                }            }                        var all_fields = false;            //some error stuff at the begining            if (isNaN(StartLat)) {                alert("Starting Latitude is not a numerical input");                all_fields = true;            } else if (isNaN(StartLong)) {                alert("Starting Longitude is not a numerical input");                all_fields = true;            } else if (isNaN(Range)) {                alert("The Range is not a numerical input");                all_fields = true;            } else if (isNaN(Bearing)) {                alert("The Bearing is not a numerical input");                all_fields = true;            } else if (isNaN(EndLat)) {                alert("Ending Latitude is not a numerical input");                all_fields = true;            } else if (isNaN(EndLong)) {                alert("Ending Longitude is not a numerical input");                all_fields = true;            }else if (isNaN(Number)) {                alert("Number is not a numerical input");                all_fields = true;            }else if (isNaN(Distance)) {                alert("Distance is not a numerical input");                all_fields = true;            }else if (Number == "") {                alert("Number isn't filled");                all_fields = true;            }else if (Distance == "") {                alert("Distance isn't filled");                all_fields = true;            } else if (StartLat != "" && StartLong != "" && Range != "" && Bearing != "" && EndLat != "" && EndLong != "") {                //if all fields are fill                all_fields = true;                alert("all fields are filled, delete what you want to be filled in");            } else if (StartLat != "" && StartLong != "" && Range == "" && Bearing == "" && EndLat != "" && EndLong != "") {                //if only Starting and Ending Latitudes and Longitudes are filled                                //getting Range (in meters)                var positions = Cesium.Cartesian3.fromDegreesArray([StartLong, StartLat, EndLong, EndLat]);                var surfacePositions = Cesium.PolylinePipeline.generateArc({                    positions: positions                });                                var scratchCartesian3 = new Cesium.Cartesian3();                var surfacePositionsLength = surfacePositions.length;                Range = 0;                for (var i = 3; i < surfacePositionsLength; i += 3) {                    scratchCartesian3.x = surfacePositions[i] - surfacePositions[i - 3];                    scratchCartesian3.y = surfacePositions[i + 1] - surfacePositions[i - 2];                    scratchCartesian3.z = surfacePositions[i + 2] - surfacePositions[i - 1];                    Range += Cesium.Cartesian3.magnitude(scratchCartesian3);                }                                //getting Bearing                var toR = Math.PI/180;                var x = Math.cos(EndLat*toR)*Math.sin(EndLong*toR-StartLong*toR);                var y = Math.cos(StartLat*toR)*Math.sin(EndLat*toR) - Math.sin(StartLat*toR)*Math.cos(EndLat*toR)*Math.cos(EndLong*toR-StartLong*toR);                Bearing = Math.atan2(x,y);                Bearing *= 180/Math.PI;                if (Bearing < 0) {                    Bearing += 360;                } else if (Bearing == 360){                    Bearing = 0;                }                            } else if (StartLat != "" && StartLong != "" && Range != "" && Bearing != "" && EndLat == "" && EndLong == "") {                //if only the Starting Latitude and Longitude and the Range and Bearing is filled                //                //This is wicked inacurrate                //                var R = 6371010; //in meters                var distRatio = Range / R;                var distRatioSine = Math.sin(distRatio);                var distRatioCosine = Math.cos(distRatio);                var startLatRad = StartLat*(Math.PI/180);                var startLonRad = StartLong*(Math.PI/180);                var startLatCos = Math.cos(startLatRad);                var startLatSin = Math.sin(startLatRad);                var endLatRads = Math.asin((startLatSin * distRatioCosine) + (startLatCos * distRatioSine * Math.cos(Bearing*(Math.PI/180))));                                var x = Math.sin(Bearing*(Math.PI/180)) * distRatioSine * startLatCos;                var y = distRatioCosine - startLatSin * Math.sin(endLatRads);                var endLonRads = startLonRad + Math.atan2(x, y);                                EndLat = endLatRads*(180/Math.PI);                EndLong = endLonRads*(180/Math.PI);                                Range = parseFloat(Range);                Bearing = parseFloat(Bearing);                            } else if (StartLat == "" && StartLong == "" && Range != "" && Bearing != "" && EndLat != "" && EndLong != "") {                //if only the Ending Latitude and Longitude and the Range and Bearing is filled            }else {                alert("not enough information");            }                        if (!all_fields) {                                //creating the initial starting pointa and line                //updating the Starting point incase it was changed                entity.position = Cesium.Cartesian3.fromDegrees(StartLong, StartLat);                entity.point.color = Cesium.Color.GREEN;                                //Creating connecting line                line = viewer.entities.add({                    name : "Line " + buttonValue,                    polyline : {                         positions : Cesium.Cartesian3.fromDegreesArray([StartLong, StartLat, EndLong, EndLat]),                         width : 3,                         material : Cesium.Color.BLUE                    }                });                //adding the start and end lat/lon values to the arrays                UserLat[(2*parseInt(buttonValue))-2] = StartLat;                UserLon[(2*parseInt(buttonValue))-2] = StartLong;                UserLat[(2*parseInt(buttonValue))-1] = EndLat;                UserLon[(2*parseInt(buttonValue))-1] = EndLong;                UserLatLong[(4*parseInt(buttonValue))-3] = StartLat;                UserLatLong[(4*parseInt(buttonValue))-4] = StartLong;                UserLatLong[(4*parseInt(buttonValue))-1] = EndLat;                UserLatLong[(4*parseInt(buttonValue))-2] = EndLong;                //update all the textboxes                viewer.infoBox.frame.contentDocument.getElementsByName("S-Latitude")[0].value = StartLat;                viewer.infoBox.frame.contentDocument.getElementsByName("S-Longitude")[0].value = StartLong;                viewer.infoBox.frame.contentDocument.getElementsByName("Range")[0].value = Range;                viewer.infoBox.frame.contentDocument.getElementsByName("Bearing")[0].value = Bearing;                viewer.infoBox.frame.contentDocument.getElementsByName("E-Latitude")[0].value = EndLat;                viewer.infoBox.frame.contentDocument.getElementsByName("E-Longitude")[0].value = EndLong;                viewer.infoBox.frame.contentDocument.getElementsByName("Number")[0].value = Number;                viewer.infoBox.frame.contentDocument.getElementsByName("Distance")[0].value = Distance;                //updating numClicks will account for the buttonValue                numClicks = UserLat.length;                entity.description = '' +                'Start Latitude: <input type="text" name="S-Latitude" id="S-Latitude" value="' + StartLat + '">[-90, 90]<br>\                Start Longitude: <input type="text" name="S-Longitude" id="S-Longitude" value="' + StartLong + '">[-180, 180]<br>\                Range: <input type="text" name="Range" id="Range" value="' + Range + '">m<br>\                Bearing: <input type="text" name="Bearing" id="Bearing" value="' + Bearing + '">Degrees<br>\                End Latitude: <input type="text" name="E-Latitude" id="E-Latitude" value="' + EndLat + '">[-90, 90]<br>\                End Longitude: <input type="text" name="E-Longitude" id="E-Longitude" value="' + EndLong + '">[-180, 180]<br>\                <div style="padding:15px"><button class="swap-start-end">Swap Start/End</button></div>\                <div style="padding:15px"><button class="Fill-in" value="' + buttonValue2 + '">Fill In</button></div>\                Number: <input type="text" name="Number" id="Number" value="' + Number + '"><br>\                Distance: <input type="text" name="Distance" id="Distance" value="' + Distance + '">m<br>';                                //Number = 4;                //Distance = 1000000;                var SLat = EndLat;                var SLong = EndLong;                var ELat;                var ELong;                var newBearing = Bearing;                var newRange = Range                for (var i = 2; i < Number*2; i++) {                    if (ELat != undefined) {                        SLat = ELat;                        SLong = ELong;                    }                    //This makes the shape of the lawn mower                    //There's a 4 step rotation, which is why I use % 4                    //There are 2 symetrical shapes, which is why there is an elseif statement                    if (Bearing >= 0 && Bearing < 180) {                        if (i % 4 == 1) {                            newBearing -= 90;                            newRange = Range;                        } else if (i % 4 == 2) {                            newBearing += 90;                            newRange = Distance/(Number-1);                        } else if (i % 4 == 3) {                            newBearing += 90;                            newRange = Range;                        } else if (i % 4 == 0) {                            newBearing -= 90;                            newRange = Distance/(Number-1);                        } else {                            alert ("something went wrong 1");                        }                    } else if (Bearing >= 180 && Bearing < 360) {                        if (i % 4 == 1) {                            newBearing += 90;                            newRange = Range;                        } else if (i % 4 == 2) {                            newBearing -= 90;                            newRange = Distance/(Number-1);                        } else if (i % 4 == 3) {                            newBearing -= 90;                            newRange = Range;                        } else if (i % 4 == 0) {                            newBearing += 90;                            newRange =  Distance/(Number-1);                        } else {                            alert ("something went wrong 2");                        }                    } else {                        alert ("something went wrong 3");                    }                    //getting new endpoints                    var R = 6371010; //in meters                    var distRatio = newRange / R;                    var distRatioSine = Math.sin(distRatio);                    var distRatioCosine = Math.cos(distRatio);                    var startLatRad = SLat*(Math.PI/180);                    var startLonRad = SLong*(Math.PI/180);                    var startLatCos = Math.cos(startLatRad);                    var startLatSin = Math.sin(startLatRad);                    var endLatRads = Math.asin((startLatSin * distRatioCosine) + (startLatCos * distRatioSine * Math.cos(newBearing*(Math.PI/180))));                    var x = Math.sin(newBearing*(Math.PI/180)) * distRatioSine * startLatCos;                    var y = distRatioCosine - startLatSin * Math.sin(endLatRads);                    var endLonRads = startLonRad + Math.atan2(x, y);                    ELat = endLatRads*(180/Math.PI);                    ELong = endLonRads*(180/Math.PI);                    //Creating start point                    var startPoint = viewer.entities.add({                        name : "Start Way Point " + i,                        position : Cesium.Cartesian3.fromDegrees(SLong, SLat),                        point : {                            pixelSize : 10,                            color : Cesium.Color.WHITE                        }                    });                    //for asthetic and functional reasons, I only create the endpoint if it's the last point                    if (i == (Number*2)-1) {                        //Creating end point                        var endPoint = viewer.entities.add({                            name : "End Way Point " + i,                            position : Cesium.Cartesian3.fromDegrees(ELong, ELat),                            point : {                                pixelSize : 10,                                color : Cesium.Color.BLACK                            }                        });                        endPoint.description = ELat + ', ' + ELong;                    }                    //Creating connecting line                    var line = viewer.entities.add({                        name : "Line " + i,                        polyline : {                             positions : Cesium.Cartesian3.fromDegreesArray([SLong, SLat, ELong, ELat]),                             width : 3,                             material : Cesium.Color.BLUE                        }                    });                    startPoint.description = '' +                    'Start Latitude: <input type="text" name="S-Latitude" id="S-Latitude" value="' + SLat + '">[-90, 90]<br>\                    Start Longitude: <input type="text" name="S-Longitude" id="S-Longitude" value="' + SLong + '">[-180, 180]<br>\                    Range: <input type="text" name="Range" id="Range" value="' + newRange + '">m<br>\                    Bearing: <input type="text" name="Bearing" id="Bearing" value="' + newBearing + '">Degrees<br>\                    End Latitude: <input type="text" name="E-Latitude" id="E-Latitude" value="' + ELat + '">[-90, 90]<br>\                    End Longitude: <input type="text" name="E-Longitude" id="E-Longitude" value="' + ELong + '">[-180, 180]<br>\                    <div style="padding:15px"><button class="swap-start-end">Swap Start/End</button></div>\                    <div style="padding:15px"><button class="Fill-in2" value="' + i + '">Fill In</button></div>';                }            }        }    }, false);}, false);//Select allows you to just use Cesium like normalSandcastle.addDefaultToolbarButton('Select', function() {    //This stuff just gets rid of all the things the other buttons do    if (handler != undefined) {        handler = handler.destroy();    }        viewer.canvas.removeEventListener('click', getLatLong_Points);    viewer.canvas.removeEventListener('click', getLatLong_Polygon);});//This creates a Way Point wherever the user clicksSandcastle.addDefaultToolbarButton('Create Way Points', function() {        if (handler != undefined) {        handler = handler.destroy();    }        viewer.canvas.removeEventListener('click', getLatLong_Polygon);    var entity = viewer.entities.add({        label : {            show : false        }    });        // Mouse over the globe to see the cartographic position    handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);    handler.setInputAction(function(movement) {        var cartesian = viewer.camera.pickEllipsoid(movement.endPosition, scene.globe.ellipsoid);        if (cartesian) {            var cartographic = Cesium.Cartographic.fromCartesian(cartesian);            var longitudeString = Cesium.Math.toDegrees(cartographic.longitude).toFixed(2);            var latitudeString = Cesium.Math.toDegrees(cartographic.latitude).toFixed(2);            entity.position = cartesian;            entity.label.show = true;            entity.label.text = '(' + latitudeString + ', ' + longitudeString + ')';        } else {            entity.label.show = false;        }    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);            viewer.canvas.addEventListener('click', getLatLong_Points, false);   });//This allows you to edit the Latitude, Longitude coordinates of a selected way pointSandcastle.addDefaultToolbarButton('Edit Way Point', function() {        if (handler != undefined) {        handler = handler.destroy();    }        viewer.canvas.removeEventListener('click', getLatLong_Points);    viewer.canvas.removeEventListener('click', getLatLong_Polygon);        var toolbar = document.getElementById('toolbar');    viewer.infoBox.frame.setAttribute('sandbox', 'allow-same-origin allow-popups allow-forms allow-scripts allow-top-navigation');        //once an entity is selected I can do stuff to it    if (Cesium.defined(viewer.selectedEntity) && Cesium.defined(viewer.selectedEntity.point)) {                var entity = viewer.selectedEntity;        var entity_name = entity.name;        var entity_number;        var entity_number = parseInt(entity_name.replace(/[^\d.]/g, ''));                //Makes the info box have a text field and a button        entity.description = '' +        UserLat[entity_number-1] + ', ' + UserLon[entity_number-1] + '<br><br>\        Latitude: <input type="text" name="Latitude" id="Latitude" value="' + UserLat[entity_number-1] + '">[-90, 90]<br>\        Longitude: <input type="text" name="Longitude" id="Longitude" value="' + UserLon[entity_number-1] + '">[-180, 180]<br>\        <div style="padding:15px"><button class="click-test-button" value="' + entity_number.toString() + '">\        Update</button></div>';    }});var polygon;//Creates a Polygon from the way pointsSandcastle.addToolbarButton('Polygon', function() {        if (handler != undefined) {        handler = handler.destroy();    }        viewer.canvas.removeEventListener('click', getLatLong_Points);        if (numClicks !== 0) {                //removing the previous polygon that was drawn        viewer.entities.remove(polygon)                //making a new polygon with added points        polygon = viewer.entities.add({        name : 'Polygon',        polygon : {            hierarchy : Cesium.Cartesian3.fromDegreesArray(UserLatLong),            height : 0,            material : Cesium.Color.YELLOW.withAlpha(0.5),            outline : true,            outlineWidth : 3,            outlineColor : Cesium.Color.BLACK        }          });        viewer.zoomTo(polygon);    } else {        viewer.canvas.addEventListener('click', getLatLong_Polygon, false);    }});Sandcastle.addToolbarButton('Lines', function() {        if (handler != undefined) {        handler = handler.destroy();    }        viewer.canvas.removeEventListener('click', getLatLong_Points);    viewer.canvas.removeEventListener('click', getLatLong_Polygon);        var toolbar = document.getElementById('toolbar');    viewer.infoBox.frame.setAttribute('sandbox', 'allow-same-origin allow-popups allow-forms allow-scripts allow-top-navigation');        //once an entity is selected I can do stuff to it    if (Cesium.defined(viewer.selectedEntity) && Cesium.defined(viewer.selectedEntity.point)) {                var entity = viewer.selectedEntity;        var entity_name = entity.name;        var entity_number = parseInt(entity_name.replace(/[^\d.]/g, ''));                //there might be a better way to do this        //but this is so the end lat/lon gets filled in with the coordinates        //of the most logical point        //probably edit this        if (UserLat[entity_number] != undefined) {            entity.description = '' +            'Start Latitude: <input type="text" name="S-Latitude" id="S-Latitude" value="' + UserLat[entity_number-1] + '">[-90, 90]<br>\            Start Longitude: <input type="text" name="S-Longitude" id="S-Longitude" value="' + UserLon[entity_number-1] + '">[-180, 180]<br>\            Range: <input type="text" name="Range" id="Range">m<br>\            Bearing: <input type="text" name="Bearing" id="Bearing">Degrees<br>\            End Latitude: <input type="text" name="E-Latitude" id="E-Latitude" value="' + UserLat[entity_number] + '">[-90, 90]<br>\            End Longitude: <input type="text" name="E-Longitude" id="E-Longitude" value="' + UserLon[entity_number] + '">[-180, 180]<br>\            <div style="padding:15px"><button class="swap-start-end">Swap Start/End</button></div>\            <div style="padding:15px"><button class="Fill-in" value="' + entity_number.toString() + '">Fill In</button></div>';        } else if (UserLat[entity_number] == undefined && UserLat[entity_number-2] != undefined) {            entity.description = '' +            'Start Latitude: <input type="text" name="S-Latitude" id="S-Latitude" value="' + UserLat[entity_number-1] + '">[-90, 90]<br>\            Start Longitude: <input type="text" name="S-Longitude" id="S-Longitude" value="' + UserLon[entity_number-1] + '">[-180, 180]<br>\            Range: <input type="text" name="Range" id="Range">m<br>\            Bearing: <input type="text" name="Bearing" id="Bearing">Degrees<br>\            End Latitude: <input type="text" name="E-Latitude" id="E-Latitude" value="' + UserLat[entity_number-2] + '">[-90, 90]<br>\            End Longitude: <input type="text" name="E-Longitude" id="E-Longitude" value="' + UserLon[entity_number-2] + '">[-180, 180]<br>\            <div style="padding:15px"><button class="swap-start-end">Swap Start/End</button></div>\            <div style="padding:15px"><button class="Fill-in" value="' + entity_number.toString() + '">Fill In</button></div>';        } else {            entity.description = '' +            'Start Latitude: <input type="text" name="S-Latitude" id="S-Latitude" value="' + UserLat[entity_number-1] + '">[-90, 90]<br>\            Start Longitude: <input type="text" name="S-Longitude" id="S-Longitude" value="' + UserLon[entity_number-1] + '">[-180, 180]<br>\            Range: <input type="text" name="Range" id="Range">m<br>\            Bearing: <input type="text" name="Bearing" id="Bearing">Degrees<br>\            End Latitude: <input type="text" name="E-Latitude" id="E-Latitude">[-90, 90]<br>\            End Longitude: <input type="text" name="E-Longitude" id="E-Longitude">[-180, 180]<br>\            <div style="padding:15px"><button class="swap-start-end">Swap Start/End</button></div>\            <div style="padding:15px"><button class="Fill-in" value="' + entity_number.toString() + '">Fill In</button></div>';        }    }});Sandcastle.addToolbarButton('Lawn Mower', function() {    if (handler != undefined) {        handler = handler.destroy();    }    viewer.canvas.removeEventListener('click', getLatLong_Points);    viewer.canvas.removeEventListener('click', getLatLong_Polygon);         var toolbar = document.getElementById('toolbar');    viewer.infoBox.frame.setAttribute('sandbox', 'allow-same-origin allow-popups allow-forms allow-scripts allow-top-navigation');        //refedining arrays with latitude, longitude coordinates once a point was changed    if (LatValue != undefined) {        UserLat[parseInt(buttonValue)-1] = LatValue;        UserLon[parseInt(buttonValue)-1] = LongValue;        UserLatLong[(2*parseInt(buttonValue))-1] = LatValue;        UserLatLong[(2*parseInt(buttonValue))-2] = LongValue;    }        //once an entity is selected I can do stuff to it    if (Cesium.defined(viewer.selectedEntity) && Cesium.defined(viewer.selectedEntity.point)) {                var entity = viewer.selectedEntity;        var entity_name = entity.name;        var entity_number = parseInt(entity_name.replace(/[^\d.]/g, ''));                //Makes the info box have a text field and a button        if (UserLat[entity_number] != undefined) {            entity.description = '' +            'Start Latitude: <input type="text" name="S-Latitude" id="S-Latitude" value="' + UserLat[entity_number-1] + '">[-90, 90]<br>\            Start Longitude: <input type="text" name="S-Longitude" id="S-Longitude" value="' + UserLon[entity_number-1] + '">[-180, 180]<br>\            Range: <input type="text" name="Range" id="Range">m<br>\            Bearing: <input type="text" name="Bearing" id="Bearing">Degrees<br>\            End Latitude: <input type="text" name="E-Latitude" id="E-Latitude" value="' + UserLat[entity_number] + '">[-90, 90]<br>\            End Longitude: <input type="text" name="E-Longitude" id="E-Longitude" value="' + UserLon[entity_number] + '">[-180, 180]<br>\            <div style="padding:15px"><button class="swap-start-end">Swap Start/End</button></div>\            <div style="padding:15px"><button class="Fill-in2" value="' + entity_number.toString() + '">Fill In</button></div>\            Number: <input type="text" name="Number" id="Number"><br>\            Distance: <input type="text" name="Distance" id="Distance">m<br>';        } else if (UserLat[entity_number] == undefined && UserLat[entity_number-2] != undefined) {            entity.description = '' +            'Start Latitude: <input type="text" name="S-Latitude" id="S-Latitude" value="' + UserLat[entity_number-1] + '">[-90, 90]<br>\            Start Longitude: <input type="text" name="S-Longitude" id="S-Longitude" value="' + UserLon[entity_number-1] + '">[-180, 180]<br>\            Range: <input type="text" name="Range" id="Range">m<br>\            Bearing: <input type="text" name="Bearing" id="Bearing">Degrees<br>\            End Latitude: <input type="text" name="E-Latitude" id="E-Latitude" value="' + UserLat[entity_number-2] + '">[-90, 90]<br>\            End Longitude: <input type="text" name="E-Longitude" id="E-Longitude" value="' + UserLon[entity_number-2] + '">[-180, 180]<br>\            <div style="padding:15px"><button class="swap-start-end">Swap Start/End</button></div>\            <div style="padding:15px"><button class="Fill-in2" value="' + entity_number.toString() + '">Fill In</button></div>\            Number: <input type="text" name="Number" id="Number"><br>\            Distance: <input type="text" name="Distance" id="Distance">m<br>';        } else {            entity.description = '' +            'Start Latitude: <input type="text" name="S-Latitude" id="S-Latitude" value="' + UserLat[entity_number-1] + '">[-90, 90]<br>\            Start Longitude: <input type="text" name="S-Longitude" id="S-Longitude" value="' + UserLon[entity_number-1] + '">[-180, 180]<br>\            Range: <input type="text" name="Range" id="Range">m<br>\            Bearing: <input type="text" name="Bearing" id="Bearing">Degrees<br>\            End Latitude: <input type="text" name="E-Latitude" id="E-Latitude">[-90, 90]<br>\            End Longitude: <input type="text" name="E-Longitude" id="E-Longitude">[-180, 180]<br>\            <div style="padding:15px"><button class="swap-start-end">Swap Start/End</button></div>\            <div style="padding:15px"><button class="Fill-in2" value="' + entity_number.toString() + '">Fill In</button></div>\            Number: <input type="text" name="Number" id="Number"><br>\            Distance: <input type="text" name="Distance" id="Distance">m<br>';        }    }});Sandcastle.addToolbarButton('Delete', function() {    if (handler != undefined) {        handler = handler.destroy();    }    viewer.canvas.removeEventListener('click', getLatLong_Points);    viewer.canvas.removeEventListener('click', getLatLong_Polygon);        viewer.entities.remove(viewer.selectedEntity);        });Sandcastle.addToolbarButton('Delete All', function() {    if (handler != undefined) {        handler = handler.destroy();    }    viewer.canvas.removeEventListener('click', getLatLong_Points);    viewer.canvas.removeEventListener('click', getLatLong_Polygon);        viewer.entities.removeAll();        numClicks = 0;    UserLatLong = [];    UserLat = [];    UserLon = [];    });//Exports the coordinates of the way points createdSandcastle.addToolbarButton('Export Coordinates', function() {        if (handler != undefined) {        handler = handler.destroy();    }    viewer.canvas.removeEventListener('click', getLatLong_Points);    viewer.canvas.removeEventListener('click', getLatLong_Polygon);        download(outStringLatLong(UserLat, UserLon), 'Coordinates.txt', 'text/plain');});//With the start and end points, you can get to the nearest centimeter//ERROR OF 3192.1417711666095m (yikes)//filling in bearing and range --> be off by 2 or 3 cemimeters for every 100 meters//229127.87216958217 (Cesium) - 246142.0896 = -17014.21743m (filling in end lat/long)////412706.99945139413m

  </script>
  
</body>
</html>