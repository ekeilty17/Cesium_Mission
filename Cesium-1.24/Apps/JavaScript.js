//defining some variables
var scene = viewer.scene;
var handler;
var handler2;

//for Points
var numClicks = 0;
var UserLat = [];
var UserLon = [];

//for Lines
var UserLines = [];

//for Polylines
var UserPolylines = [];

//to keep an index of the order things were drawn
var Order = [];

//gets rid of that dumb double click action
viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);



// CAUTION: Only disable iframe sandbox if the descriptions come from a trusted source
//This is to allow buttons to be accessed while inside the info box, otherwise when you press them nothing will happen
viewer.infoBox.frame.setAttribute('sandbox', 'allow-same-origin allow-popups allow-forms allow-scripts allow-top-navigation');


//These are functions for buttons that are within what Cesium calls the "Info Box"


//This will be the button inside the Info box generated by the 'Edit Way Point' button

// Since the viewer is newly constructed, the iframe is still about:blank.
// This listens for the iframe to change to the Cesium description template,
// which only happens once at startup.
viewer.infoBox.frame.addEventListener('load', function() {
    // Now that the description is loaded, register a click listener inside
    // the document of the iframe.
    viewer.infoBox.frame.contentDocument.body.addEventListener('click', function(e) {
        // The document body will be rewritten when the selectedEntity changes,
        // but this body listener will survive.  Now it must determine if it was
        // one of the clickable buttons.

	if (e.target && e.target.className === 'Editing_Point') {
            	//alert("Editing Point");
		
		//defining the selected entity, which we know will be a point
		var selected_point = viewer.selectedEntity;
		var selected_point_number = parseInt(selected_point.name.replace(/[^\d.]/g, ''));
		
		//getting the information from the text-fields
		var LatValue = viewer.infoBox.frame.contentDocument.getElementsByName("Latitude")[0].value;
		var LongValue = viewer.infoBox.frame.contentDocument.getElementsByName("Longitude")[0].value;

		//make sure the inputted coordinates are in the correct domain
		if (LatValue < -90 || LatValue > 90 || LongValue < -180 || LongValue > 180) {
			alert("Point is out of range");
		} else if (LatValue == "") {
			alert("Latitude value is not filled in");
		} else if (LongValue == "") {
			alert("Longitude value is not filled in");
		} else {
			//updating the points position
			selected_point.position = Cesium.Cartesian3.fromDegrees(LongValue, LatValue);
			
			//redefining arrays with latitude, longitude coordinates once a point was changed
			UserLat[selected_point_number-1] = LatValue;
			UserLon[selected_point_number-1] = LongValue;

			//Makes the info box have a text field and a button
        		selected_point.description = '' +
        		UserLat[selected_point_number-1] + ', ' + UserLon[selected_point_number-1] + '<br><br>\
        		Latitude: <input type="text" name="Latitude" id="Latitude" value="' + UserLat[selected_point_number-1] + '">[-90, 90]<br>\
        		Longitude: <input type="text" name="Longitude" id="Longitude" value="' + UserLon[selected_point_number-1] + '">[-180, 180]<br>\
			<div><button class="Editing_Point">Update</button></div>'
		}
        }
    }, false);
}, false);



//This will be the buttons inside the Info box generated by the 'Line' button
viewer.infoBox.frame.addEventListener('load', function() {

    viewer.infoBox.frame.contentDocument.body.addEventListener('click', function(e) {
	
	if (e.target && e.target.className === 'swap_start_end_line') {
            //alert("Swap Line");
            var StartLat = viewer.infoBox.frame.contentDocument.getElementsByName("S-Latitude")[0].value;
            var StartLong = viewer.infoBox.frame.contentDocument.getElementsByName("S-Longitude")[0].value;
            var Range = viewer.infoBox.frame.contentDocument.getElementsByName("Range")[0].value;
            var Bearing = viewer.infoBox.frame.contentDocument.getElementsByName("Bearing")[0].value;
            var EndLat = viewer.infoBox.frame.contentDocument.getElementsByName("E-Latitude")[0].value;
            var EndLong = viewer.infoBox.frame.contentDocument.getElementsByName("E-Longitude")[0].value;
            
            //some error stuff
            if (StartLat == "" || StartLong == "") {
                alert("Starting Latitude and Longitude are undefined");
            }else if (EndLat == "" || EndLong == "") {
                alert("Ending Latitude and Longitude are undefined");
            }else if(StartLat < -90 || StartLat > 90 || StartLong < -180 || StartLong > 180) {
                alert("Starting Latitude and Longitude are out of range");
            }else if(EndLat < -90 || EndLat > 90 || EndLong < -180 || EndLong > 180) {
                alert("Starting Latitude and Longitude are out of range");
            } else {
                //actually coding the button's function
                viewer.infoBox.frame.contentDocument.getElementsByName("E-Latitude")[0].value = StartLat;
                viewer.infoBox.frame.contentDocument.getElementsByName("E-Longitude")[0].value = StartLong;
                viewer.infoBox.frame.contentDocument.getElementsByName("S-Latitude")[0].value = EndLat;
                viewer.infoBox.frame.contentDocument.getElementsByName("S-Longitude")[0].value = EndLong;
                
                if (Range != "" && Bearing != "") {
                    //update the range and bearing
                    
                    //The Range will not change
                    //However, the Bearing will
                    var toR = Math.PI/180;
                    var x = Math.cos(StartLat*toR)*Math.sin(StartLong*toR-EndLong*toR);
                    var y = Math.cos(EndLat*toR)*Math.sin(StartLat*toR) - Math.sin(EndLat*toR)*Math.cos(StartLat*toR)*Math.cos(StartLong*toR-EndLong*toR);
                    Bearing = Math.atan2(x,y);
                    Bearing *= 180/Math.PI;
                    if (Bearing < 0) {
                        Bearing += 360;
                    } else if (Bearing == 360){
                        Bearing = 0;
                    }
                    viewer.infoBox.frame.contentDocument.getElementsByName("Bearing")[0].value = Bearing;
                }
	     }
	} else if (e.target && e.target.className === 'Making_Line') {
            //alert("Making Line");
            
	     //defining the selected entity, which we know will be a point
            var selected_point = viewer.selectedEntity;
            var selected_point_number = parseInt(selected_point.name.replace(/[^\d.]/g, ''));
            
	     //getting the information from the text-fields
            var StartLat = viewer.infoBox.frame.contentDocument.getElementsByName("S-Latitude")[0].value;
            var StartLong = viewer.infoBox.frame.contentDocument.getElementsByName("S-Longitude")[0].value;
            var Range = viewer.infoBox.frame.contentDocument.getElementsByName("Range")[0].value;
            var Bearing = viewer.infoBox.frame.contentDocument.getElementsByName("Bearing")[0].value;
            var EndLat = viewer.infoBox.frame.contentDocument.getElementsByName("E-Latitude")[0].value;
            var EndLong = viewer.infoBox.frame.contentDocument.getElementsByName("E-Longitude")[0].value;
	     
	     //if Bearing is negative or over 360, we change it to fit in the domain 0 < x < 360
            if (Bearing != "" && !isNaN(Bearing)) {
                Bearing = parseFloat(Bearing);
                while (Bearing > 360) {
                    Bearing -= 360;
                }

                while (Bearing < 0) {
                    Bearing += 360
                }
            }
            
	     //I needed a way to stop the program if there was not enough information, ambiguous information, or bad input in the textbooks
	     //This was the simplest way I could come up with
            var correct_input = false;

	     //various valid combinations of inputs into the text fields
	     if (StartLat != "" && StartLong != "" && Range != "" && Bearing != "" && EndLat != "" && EndLong != "") {
                //if all fields are fill
                alert("all fields are filled, delete what you want to be filled in");
            } else if (StartLat != "" && StartLong != "" && Range == "" && Bearing == "" && EndLat != "" && EndLong != "") {
                //if only Starting and Ending Latitudes and Longitudes are filled
		 correct_input = true;

                //getting Range (in meters)
                var positions = Cesium.Cartesian3.fromDegreesArray([StartLong, StartLat, EndLong, EndLat]);
                var surfacePositions = Cesium.PolylinePipeline.generateArc({
                    positions: positions
                });
                
                var scratchCartesian3 = new Cesium.Cartesian3();
                var surfacePositionsLength = surfacePositions.length;
                Range = 0;
                for (var i = 3; i < surfacePositionsLength; i += 3) {
                    scratchCartesian3.x = surfacePositions[i] - surfacePositions[i - 3];
                    scratchCartesian3.y = surfacePositions[i + 1] - surfacePositions[i - 2];
                    scratchCartesian3.z = surfacePositions[i + 2] - surfacePositions[i - 1];
                    Range += Cesium.Cartesian3.magnitude(scratchCartesian3);
                }
                
                //getting Bearing
                var toR = Math.PI/180;
                var x = Math.cos(EndLat*toR)*Math.sin(EndLong*toR-StartLong*toR);
                var y = Math.cos(StartLat*toR)*Math.sin(EndLat*toR) - Math.sin(StartLat*toR)*Math.cos(EndLat*toR)*Math.cos(EndLong*toR-StartLong*toR);
                Bearing = Math.atan2(x,y);
                Bearing *= 180/Math.PI;
                if (Bearing < 0) {
                    Bearing += 360;
                } else if (Bearing == 360){
                    Bearing = 0;
                }
                
            } else if (StartLat != "" && StartLong != "" && Range != "" && Bearing != "" && EndLat == "" && EndLong == "") {
                //if only the Starting Latitude and Longitude and the Range and Bearing is filled
		 correct_input = true;

                var R = 6371010; //in meters
                var distRatio = Range / R;
                var distRatioSine = Math.sin(distRatio);
                var distRatioCosine = Math.cos(distRatio);

                var startLatRad = StartLat*(Math.PI/180);
                var startLonRad = StartLong*(Math.PI/180);

                var startLatCos = Math.cos(startLatRad);
                var startLatSin = Math.sin(startLatRad);

                var endLatRads = Math.asin((startLatSin * distRatioCosine) + (startLatCos * distRatioSine * Math.cos(Bearing*(Math.PI/180))));
                
                var x = Math.sin(Bearing*(Math.PI/180)) * distRatioSine * startLatCos;
                var y = distRatioCosine - startLatSin * Math.sin(endLatRads);
                var endLonRads = startLonRad + Math.atan2(x, y);
                
                EndLat = endLatRads*(180/Math.PI);
                EndLong = endLonRads*(180/Math.PI);
                
            } else if (StartLat == "" && StartLong == "" && Range != "" && Bearing != "" && EndLat != "" && EndLong != "") {
                //if only the Ending Latitude and Longitude and the Range and Bearing is filled
		 correct_input = true;
            }else {
                alert("not enough or ambiguous information");
            }
            
	     //some error stuff at the end to make sure the code stops if the input is bad
	     //Checks if it's a number
            if (isNaN(StartLat)) {
		 correct_input = false;
                alert("Starting Latitude is not a numerical input");
            } else if (isNaN(StartLong)) {
		 correct_input = false;
                alert("Starting Longitude is not a numerical input");
            } else if (isNaN(Range)) {
		 correct_input = false;
                alert("The Range is not a numerical input");
            } else if (isNaN(Bearing)) {
		 correct_input = false;
                alert("The Bearing is not a numerical input");
            } else if (isNaN(EndLat)) {
		 correct_input = false;
                alert("Ending Latitude is not a numerical input");
            } else if (isNaN(EndLong)) {
		 correct_input = false;
                alert("Ending Longitude is not a numerical input");
            } 

	    //Checks if that number is within the proper range
	    if (StartLat < -90 || StartLat > 90) {
		 correct_input = false;
                alert("Starting Latitude is out of range");
            } else if (StartLong < -180 || StartLong > 180) {
		 correct_input = false;
                alert("Starting Longitude is out of range");
            } else if (Range < 0 || Range > 21,000,000) {
		 correct_input = false;
                alert("The Range is out of range");
            } else if (Bearing < 0 || Bearing > 360) {
		 correct_input = false;
                alert("The Bearing is out of range");
            } else if (EndLat < -90 || EndLat > 90) {
		 correct_input = false;
                alert("Ending Latitude is out of range");
            } else if (EndLong < -180 || EndLong > 180) {
		 correct_input = false;
                alert("Ending Longitude is out of range");
            }


            if (correct_input) {
                
                //updating the starting point incase it was changed
                selected_point.position = Cesium.Cartesian3.fromDegrees(StartLong, StartLat);
        	 
		 //Updating its value in the array
		 UserLat[selected_point_number-1] = StartLat;
		 UserLon[selected_point_number-1] = StartLong;
		 
		 
                //Creating end point
                var endPoint = viewer.entities.add({
                    name : "End Point " + selected_point_number.toString(),
                    position : Cesium.Cartesian3.fromDegrees(EndLong, EndLat),
                    point : {
                        pixelSize : 10,
                        color : Cesium.Color.BLACK
                    }
                });
		 endPoint.description = EndLat.toString() + ', ' + EndLong.toString();


		 //The end point doesn't get added to the UserLat and UserLong array, 
		 //because then it would screw up the position off all subsequent points
		 //This is why we have a separate array for lines, so we can include the end points
		 //So 'Line 1' could contain 'Point 4' and 'End Point 4', but it is stored as 'Line 1'
		 UserLines.push([StartLat, StartLong, EndLat, EndLong]);
		 var numLines = UserLines.length;

                //Creating connecting line
                var line = viewer.entities.add({
                    name : "Line " + numLines.toString(),
                    polyline : {
                         positions : Cesium.Cartesian3.fromDegreesArray([StartLong, StartLat, EndLong, EndLat]),
                         width : 3,
                         material : Cesium.Color.BLUE
                    }
                });
		 Order.push("L" + numLines.toString());
		
		 line.description = '' + 
                '<div>Start Latitude: ' + StartLat + '</div>\
                 <div>Start Longitude: ' + StartLong + '<div>\
		  <div>Range: ' + Range + '</div>\
                 <div>Bearing: ' + Bearing + '<div>\
                 <div>End Latitude: ' + EndLat + '</div>\
                 <div>End Longitude: ' + EndLong + '<div>';
		 
		 
		 //Updating all the textboxes
                selected_point.description = '' +
                'Start Latitude: <input type="text" name="S-Latitude" id="S-Latitude" value="' + StartLat + '">[-90, 90]<br>\
                Start Longitude: <input type="text" name="S-Longitude" id="S-Longitude" value="' + StartLong + '">[-180, 180]<br>\
                Range: <input type="text" name="Range" id="Range" value="' + Range + '">m<br>\
                Bearing: <input type="text" name="Bearing" id="Bearing" value="' + Bearing + '">Degrees<br>\
                End Latitude: <input type="text" name="E-Latitude" id="E-Latitude" value="' + EndLat + '">[-90, 90]<br>\
                End Longitude: <input type="text" name="E-Longitude" id="E-Longitude" value="' + EndLong + '">[-180, 180]<br>\
                <div><button class="swap_start_end">Swap Start/End</button></div>\
                <div><button class="Making_Line">Fill In</button></div>';
            }
	}
    }, false);
}, false);


//This will be the buttons inside the Info box generated by the 'Lawn Mower' button
viewer.infoBox.frame.addEventListener('load', function() {

    viewer.infoBox.frame.contentDocument.body.addEventListener('click', function(e) {
	
	if (e.target && e.target.className === 'swap_start_end_Lawn_Mower') {
            //alert("Swap Lawn Mower");
            var StartLat = viewer.infoBox.frame.contentDocument.getElementsByName("S-Latitude")[0].value;
            var StartLong = viewer.infoBox.frame.contentDocument.getElementsByName("S-Longitude")[0].value;
            var Range = viewer.infoBox.frame.contentDocument.getElementsByName("Range")[0].value;
            var Bearing = viewer.infoBox.frame.contentDocument.getElementsByName("Bearing")[0].value;
            var EndLat = viewer.infoBox.frame.contentDocument.getElementsByName("E-Latitude")[0].value;
            var EndLong = viewer.infoBox.frame.contentDocument.getElementsByName("E-Longitude")[0].value;
            
            //some error stuff
            if (StartLat == "" || StartLong == "") {
                alert("Starting Latitude and Longitude are undefined");
            }else if (EndLat == "" || EndLong == "") {
                alert("Ending Latitude and Longitude are undefined");
            }else if(StartLat < -90 || StartLat > 90 || StartLong < -180 || StartLong > 180) {
                alert("Starting Latitude and Longitude are out of range");
            }else if(EndLat < -90 || EndLat > 90 || EndLong < -180 || EndLong > 180) {
                alert("Starting Latitude and Longitude are out of range");
            } else {
                //actually coding the button's function
                viewer.infoBox.frame.contentDocument.getElementsByName("E-Latitude")[0].value = StartLat;
                viewer.infoBox.frame.contentDocument.getElementsByName("E-Longitude")[0].value = StartLong;
                viewer.infoBox.frame.contentDocument.getElementsByName("S-Latitude")[0].value = EndLat;
                viewer.infoBox.frame.contentDocument.getElementsByName("S-Longitude")[0].value = EndLong;
                
                if (Range != "" && Bearing != "") {
                    //update the range and bearing
                    
                    //The Range will not change
                    //However, the Bearing will
                    var toR = Math.PI/180;
                    var x = Math.cos(StartLat*toR)*Math.sin(StartLong*toR-EndLong*toR);
                    var y = Math.cos(EndLat*toR)*Math.sin(StartLat*toR) - Math.sin(EndLat*toR)*Math.cos(StartLat*toR)*Math.cos(StartLong*toR-EndLong*toR);
                    Bearing = Math.atan2(x,y);
                    Bearing *= 180/Math.PI;
                    if (Bearing < 0) {
                        Bearing += 360;
                    } else if (Bearing == 360){
                        Bearing = 0;
                    }
                    viewer.infoBox.frame.contentDocument.getElementsByName("Bearing")[0].value = Bearing;
                }
	     }
	} else if (e.target && e.target.className === 'Making_Lawn_Mower') {
            //alert("Making Lawn Mower");

            //defining the selected entity, which we know will be a point
            var selected_point = viewer.selectedEntity;
            var selected_point_number = parseInt(selected_point.name.replace(/[^\d.]/g, ''));
            
	     //getting the information from the text-fields
	     var StartLat = viewer.infoBox.frame.contentDocument.getElementsByName("S-Latitude")[0].value;
            var StartLong = viewer.infoBox.frame.contentDocument.getElementsByName("S-Longitude")[0].value;
            var Range = viewer.infoBox.frame.contentDocument.getElementsByName("Range")[0].value;
            var Bearing = viewer.infoBox.frame.contentDocument.getElementsByName("Bearing")[0].value;
            var EndLat = viewer.infoBox.frame.contentDocument.getElementsByName("E-Latitude")[0].value;
            var EndLong = viewer.infoBox.frame.contentDocument.getElementsByName("E-Longitude")[0].value;
            var Number = viewer.infoBox.frame.contentDocument.getElementsByName("Number")[0].value;
            var Width = viewer.infoBox.frame.contentDocument.getElementsByName("Width")[0].value;
            var Spacing = viewer.infoBox.frame.contentDocument.getElementsByName("Spacing")[0].value;
            
	     //if Bearing is negative or over 360, we change it to fit in the domain 0 < x < 360
            if (Bearing != "" && !isNaN(Bearing)) {
                Bearing = parseFloat(Bearing);
                while (Bearing > 360) {
                    Bearing -= 360;
                }

                while (Bearing < 0) {
                    Bearing += 360
                }
            }
            
            //I needed a way to stop the program if there was not enough information, ambiguous information, or bad input in the textbooks
	     //This was the simplest way I could come up with
            var correct_input = false;
            
	     //various valid combinations of inputs into the text fields above the buttons
	     //This is the orientation of the polyline
            //a lot of this code is the same as in the 'Making_line' button
            if (StartLat != "" && StartLong != "" && Range != "" && Bearing != "" && EndLat != "" && EndLong != "") {
                //if all fields are fill
                alert("all fields are filled, delete what you want to be filled in");
            } else if (StartLat != "" && StartLong != "" && Range == "" && Bearing == "" && EndLat != "" && EndLong != "") {
                //if only Starting and Ending Latitudes and Longitudes are filled
		 correct_input = true;

                //getting Range (in meters)
                var positions = Cesium.Cartesian3.fromDegreesArray([StartLong, StartLat, EndLong, EndLat]);
                var surfacePositions = Cesium.PolylinePipeline.generateArc({
                    positions: positions
                });
                
                var scratchCartesian3 = new Cesium.Cartesian3();
                var surfacePositionsLength = surfacePositions.length;
                Range = 0;
                for (var i = 3; i < surfacePositionsLength; i += 3) {
                    scratchCartesian3.x = surfacePositions[i] - surfacePositions[i - 3];
                    scratchCartesian3.y = surfacePositions[i + 1] - surfacePositions[i - 2];
                    scratchCartesian3.z = surfacePositions[i + 2] - surfacePositions[i - 1];
                    Range += Cesium.Cartesian3.magnitude(scratchCartesian3);
                }
                
                //getting Bearing
                var toR = Math.PI/180;
                var x = Math.cos(EndLat*toR)*Math.sin(EndLong*toR-StartLong*toR);
                var y = Math.cos(StartLat*toR)*Math.sin(EndLat*toR) - Math.sin(StartLat*toR)*Math.cos(EndLat*toR)*Math.cos(EndLong*toR-StartLong*toR);
                Bearing = Math.atan2(x,y);
                Bearing *= 180/Math.PI;
                if (Bearing < 0) {
                    Bearing += 360;
                } else if (Bearing == 360){
                    Bearing = 0;
                }
                
            } else if (StartLat != "" && StartLong != "" && Range != "" && Bearing != "" && EndLat == "" && EndLong == "") {
                //if only the Starting Latitude and Longitude and the Range and Bearing is filled
		 correct_input = true;

                var R = 6371010; //in meters
                var distRatio = Range / R;
                var distRatioSine = Math.sin(distRatio);
                var distRatioCosine = Math.cos(distRatio);

                var startLatRad = StartLat*(Math.PI/180);
                var startLonRad = StartLong*(Math.PI/180);

                var startLatCos = Math.cos(startLatRad);
                var startLatSin = Math.sin(startLatRad);

                var endLatRads = Math.asin((startLatSin * distRatioCosine) + (startLatCos * distRatioSine * Math.cos(Bearing*(Math.PI/180))));
                
                var x = Math.sin(Bearing*(Math.PI/180)) * distRatioSine * startLatCos;
                var y = distRatioCosine - startLatSin * Math.sin(endLatRads);
                var endLonRads = startLonRad + Math.atan2(x, y);
                
                EndLat = endLatRads*(180/Math.PI);
                EndLong = endLonRads*(180/Math.PI);
                
                Range = parseFloat(Range);
                Bearing = parseFloat(Bearing);
                
            } else if (StartLat == "" && StartLong == "" && Range != "" && Bearing != "" && EndLat != "" && EndLong != "") {
                //if only the Ending Latitude and Longitude and the Range and Bearing is filled
		 correct_input = true;
            }else {
                alert("not enough or ambiguous information");
            }
            
	     //various valid combinations of inputs into the text fields above the buttons
	     //This is the size and density of the polyline
            if (Number != "" && Width != "" && Spacing != "") {
                //if all fields are fill
                alert("all fields are filled, delete what you want to be filled in");
            } else if (Number == "" && Width != "" && Spacing != "") {
                //if Width and Spacing is filled in
		 correct_input = true;

                Number = Math.round(Width / Spacing);
		 
		 //fix width
                //Spacing = Width / Number;
                
		 //fix spacing
		 Width = Spacing * Number;
            } else if (Number != "" && Width == "" && Spacing != "") {
                //if Number and Spacing is filled in
		 correct_input = true;

                Width = Number * Spacing;
            } else if (Number != "" && Width != "" && Spacing == "") {
                //if Number and Width is filled in
		 correct_input = true;

                Spacing = Width / Number;
            } else {
                alert("not enough or ambiguous information");
            }
            
	    //some error stuff at the end to make sure the code stops if the input is bad
            if (isNaN(StartLat)) {
            	 correct_input = false;
                alert("Starting Latitude is not a numerical input");
            } else if (isNaN(StartLong)) {
            	 correct_input = false;
                alert("Starting Longitude is not a numerical input");
            } else if (isNaN(Range)) {
            	 correct_input = false;
                alert("The Range is not a numerical input");
            } else if (isNaN(Bearing)) {
            	 correct_input = false;
                alert("The Bearing is not a numerical input");
            } else if (isNaN(EndLat)) {
            	 correct_input = false;
                alert("Ending Latitude is not a numerical input");
            } else if (isNaN(EndLong)) {
            	 correct_input = false;
                alert("Ending Longitude is not a numerical input");
            } else if (isNaN(Number)) {
            	 correct_input = false;
                alert("Number is not a numerical input");
	     } else if (parseInt(Number) != Number) {
            	 correct_input = false;
                alert("Number is not an integer");
            } else if (isNaN(Width)) {
            	 correct_input = false;
                alert("Width is not a numerical input");
            } else if (isNaN(Spacing)) {
            	 correct_input = false;
                alert("Spacing is not a numerical input");
            }

	    //Checks if that number is within the proper range
	    if (StartLat < -90 || StartLat > 90) {
		 correct_input = false;
                alert("Starting Latitude is out of range");
            } else if (StartLong < -180 || StartLong > 180) {
		 correct_input = false;
                alert("Starting Longitude is out of range");
            } else if (Range < 0 || Range > 21,000,000) {
		 correct_input = false;
                alert("The Range is out of range");
            } else if (Bearing < 0 || Bearing > 360) {
		 correct_input = false;
                alert("The Bearing is out of range");
            } else if (EndLat < -90 || EndLat > 90) {
		 correct_input = false;
                alert("Ending Latitude is out of range");
            } else if (EndLong < -180 || EndLong > 180) {
		 correct_input = false;
                alert("Ending Longitude is out of range");

            } else if (Number <= 0) {
            	 correct_input = false;
                alert("Number is out of range");
            } else if (Width <= 0) {
            	 correct_input = false;
                alert("Width is out of range");
            } else if (Spacing <= 0) {
            	 correct_input = false;
                alert("Spacing is out of range");
            }
	    
	    //checks if the radio buttons were checked
	    var handed;
	    if (!viewer.infoBox.frame.contentDocument.getElementById('left').checked && !viewer.infoBox.frame.contentDocument.getElementById('right').checked) {
		correct_input = false;
		alert("Selected either a right-handed or left-handed Lawn Mower");
	    } else if (viewer.infoBox.frame.contentDocument.getElementById('left').checked) {
		handed = "left";
	    } else if (viewer.infoBox.frame.contentDocument.getElementById('right').checked) {
		handed = "right";
	    }

            //if everything is put in properly, then we can continue
            if (correct_input) {
                //creating the initial starting point and line
                
		 //updating the Starting point incase it was changed
		 //and making it green to indicate it's the starting point of a Lawn Mower
                selected_point.position = Cesium.Cartesian3.fromDegrees(StartLong, StartLat);
                selected_point.point.color = Cesium.Color.GREEN;
		 
		 //Updating the points array for the initial point 
		 UserLat[selected_point_number-1] = StartLat;
		 UserLon[selected_point_number-1] = StartLong;
		
		 //Making it so that whatever radio button the user checked stays checked
		 var left_checked = "";
		 var right_checked = "";
		 if (handed == "left") {
		 	left_checked = "checked";
		 } else if (handed == "right") {
		 	right_checked = "checked";
		 }

                selected_point.description = '' +
                'Start Latitude: <input type="text" name="S-Latitude" id="S-Latitude" value="' + StartLat + '">[-90, 90]<br>\
                Start Longitude: <input type="text" name="S-Longitude" id="S-Longitude" value="' + StartLong + '">[-180, 180]<br>\
                Range: <input type="text" name="Range" id="Range" value="' + Range + '">m<br>\
                Bearing: <input type="text" name="Bearing" id="Bearing" value="' + Bearing + '">Degrees<br>\
                End Latitude: <input type="text" name="E-Latitude" id="E-Latitude" value="' + EndLat + '">[-90, 90]<br>\
                End Longitude: <input type="text" name="E-Longitude" id="E-Longitude" value="' + EndLong + '">[-180, 180]<br>\
                <div><button class="swap_start_end_Lawn_Mower">Swap Start/End</button></div>\
                <div><button class="Making_Lawn_Mower">Fill In</button></div>\
                <form action="">\
  			<input type="radio" name="handed" id="left" value="left"' + left_checked + '> Left-handed\
  			<input type="radio" name="handed" id="right" value="right"' + right_checked + '> Right-handed<br>\
            	 </form>\
                Number of Lines: <input type="text" name="Number" id="Number" value="' + Number + '"><br>\
                Spacing: <input type="text" name="Spacing" id="Spacing" value="' + Spacing + '">m<br>\
                Width: <input type="text" name="Width" id="Width" value="' + Width + '">m<br>';

		 //again, we aren't going to add every point the Lawn Mower function creates to the points array,
		 //only the initial point
		 //We will add the remaining points to the UserPolylines array;
		 //Similar to how we keep track of lines, 'Polyline 1' could contain 'Point 6' as its starting point
                
		 //getting the points for the polyline
                var polylineArray = getLatLong_Polyline(StartLat, StartLong, EndLat, EndLong, Range, Bearing, Number, Width, handed);
                UserPolylines.push(polylineArray);
		 var numPolylines = UserPolylines.length;

                //creating polyline
                var polyline = viewer.entities.add({
                    name : "Polyline " + numPolylines,
                    polyline : {
                        positions : Cesium.Cartesian3.fromDegreesArray(polylineArray),
                        width : 2,
                        material : Cesium.Color.BLUE
                    }
                });
		 Order.push("M" + numPolylines);

                polyline.description = '' + 
                '<div>Start Latitude: ' + StartLat + '</div>\
                 <div>Start Longitude: ' + StartLong + '<div>\
		  <div>Range: ' + Range + '</div>\
                 <div>Bearing: ' + Bearing + '<div>\
                 <div>End Latitude: ' + EndLat + '</div>\
                 <div>End Longitude: ' + EndLong + '<div>\
		  <div>Number: ' + Number + '</div>\
		  <div>Spacing: ' + Spacing + '</div>\
		  <div>Width: ' + Width + '</div>';
            }

	}

    }, false);
}, false);



//  _____________
// |		  |
// |		  |
// |		  |
// |    Break    |
// |		  |
// |		  |
// |_____________|
//



//These are the functions associated with each button
//the commented out alerts are just to test to see if pressing the buttons work



//The 'Select' button allows you to just use Cesium as it is 
//and it removes all functionality acquired by the other buttons
function Select_function() {
	//alert("Select");
	//This stuff just gets rid of all the things the other buttons do
    	if (handler != undefined) {
        	handler = handler.destroy();
    	}
        
	if (handler2 != undefined) {
        	handler2 = handler2.destroy();
	}

	
    	viewer.canvas.removeEventListener('click', getLatLong_Points);
    	viewer.canvas.removeEventListener('click', getLatLong_Polygon);
}

//The 'Create Way Points' button allows you to create as many way points as you like
function Create_function() {
	//alert("Create");
	if (handler != undefined) {
        	handler = handler.destroy();
    	}
    	
	if (handler2 != undefined) {
        	handler2 = handler2.destroy();
	}
	
    	viewer.canvas.removeEventListener('click', getLatLong_Polygon);
    	var entity = viewer.entities.add({
        	label : {
            		show : false
        	}
    	});
	//This honestly just started to annoy me. if you want to put it back it, the code should still work
       /*
    	// Mouse over the globe to see the cartographic position
    	handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
    	handler.setInputAction(function(movement) {
        	var cartesian = viewer.camera.pickEllipsoid(movement.endPosition, scene.globe.ellipsoid);
        	if (cartesian) {
            		var cartographic = Cesium.Cartographic.fromCartesian(cartesian);
            		var longitudeString = Cesium.Math.toDegrees(cartographic.longitude).toFixed(2);
            		var latitudeString = Cesium.Math.toDegrees(cartographic.latitude).toFixed(2);

            		entity.position = cartesian;
            		entity.label.show = true;
            		entity.label.text = '(' + latitudeString + ', ' + longitudeString + ')';
        	} else {
            		entity.label.show = false;
        	}
    	}, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
        */
	
    	viewer.canvas.addEventListener('click', getLatLong_Points, false);
	//getLatLong_Points() is in the Functions.js file, near the bottom
}


//The 'Edit Way Point' button allows you to edit any selected way point
function Edit_function() {
	//alert("Edit");
	if (handler != undefined) {
        	handler = handler.destroy();
    	}
	
	if (handler2 != undefined) {
        	handler2 = handler2.destroy();
	}
	
    	viewer.canvas.removeEventListener('click', getLatLong_Points);
    	viewer.canvas.removeEventListener('click', getLatLong_Polygon);
    
    	//once an entity is selected I can do stuff to it
    	if (Cesium.defined(viewer.selectedEntity) && Cesium.defined(viewer.selectedEntity.point)) {
        
        	var entity = viewer.selectedEntity;
        	var entity_name = entity.name;
        	var entity_number;
        	var entity_number = parseInt(entity_name.replace(/[^\d.]/g, ''));
        
        	//Makes the info box have a text field and a button
        	entity.description = '' +
        	UserLat[entity_number-1] + ', ' + UserLon[entity_number-1] + '<br><br>\
        	Latitude: <input type="text" name="Latitude" id="Latitude" value="' + UserLat[entity_number-1] + '">[-90, 90]<br>\
        	Longitude: <input type="text" name="Longitude" id="Longitude" value="' + UserLon[entity_number-1] + '">[-180, 180]<br>\
		<div><button class="Editing_Point">Update</button></div>'
    	}
}


//The 'Polygon' button creates a polygon from the pre-existing points
//the points are connected in the order they were created in
function Polygon_function() {
	//alert("Polygon");
	if (handler != undefined) {
        	handler = handler.destroy();
    	}
    	
	if (handler2 != undefined) {
        	handler2 = handler2.destroy();
	}
	
    	viewer.canvas.removeEventListener('click', getLatLong_Points);
       
	var polygon;
    	if (numClicks !== 0) {
        
        	//removing the previous polygon that was drawn
        	viewer.entities.remove(polygon)
        	
		var combinedLatLong = [];
		for (var i=0; i < UserLat.length; i++) {
			combinedLatLong.push(UserLon[i], UserLat[i]);
		}
		
        	//making a new polygon with added points
        	polygon = viewer.entities.add({
        		name : 'Polygon',
        		polygon : {
            			hierarchy : Cesium.Cartesian3.fromDegreesArray(combinedLatLong),
            			height : 0,
            			material : Cesium.Color.YELLOW.withAlpha(0.5),
            			outline : true,
            			outlineWidth : 3,
            			outlineColor : Cesium.Color.BLACK
        		}  
       		});

        	viewer.zoomTo(polygon);
    	} else {
        	viewer.canvas.addEventListener('click', getLatLong_Polygon, false);
    	}
}

//The 'Lines' button allows you to create a line from any way point to another
//There are 6 input boxes, but only 4 needs to be filled in and it will calculate the remaining 2
function Lines_function() {
    //alert("Lines");
    if (handler != undefined) {
        handler = handler.destroy();
    }
    
    if (handler2 != undefined) {
        handler2 = handler2.destroy();
    }

    viewer.canvas.removeEventListener('click', getLatLong_Points);
    viewer.canvas.removeEventListener('click', getLatLong_Polygon);
    
    //once an entity is selected I can do stuff to it
    if (Cesium.defined(viewer.selectedEntity) && Cesium.defined(viewer.selectedEntity.point)) {
        
        var entity = viewer.selectedEntity;
        var entity_number = parseInt(entity.name.replace(/[^\d.]/g, ''));
        
        //there might be a better way to do this
        //but this is so the end lat/lon gets filled in with the coordinates of the most logical point
        if (UserLat[entity_number] != undefined) {
            entity.description = '' +
            'Start Latitude: <input type="text" name="S-Latitude" id="S-Latitude" value="' + UserLat[entity_number-1] + '">[-90, 90]<br>\
            Start Longitude: <input type="text" name="S-Longitude" id="S-Longitude" value="' + UserLon[entity_number-1] + '">[-180, 180]<br>\
            Range: <input type="text" name="Range" id="Range">m<br>\
            Bearing: <input type="text" name="Bearing" id="Bearing">Degrees<br>\
            End Latitude: <input type="text" name="E-Latitude" id="E-Latitude" value="' + UserLat[entity_number] + '">[-90, 90]<br>\
            End Longitude: <input type="text" name="E-Longitude" id="E-Longitude" value="' + UserLon[entity_number] + '">[-180, 180]<br>\
            <div><button class="swap_start_end_line">Swap Start/End</button></div>\
            <div><button class="Making_Line">Fill In</button></div>';
        } else if (UserLat[entity_number] == undefined && UserLat[entity_number-2] != undefined) {
            entity.description = '' +
            'Start Latitude: <input type="text" name="S-Latitude" id="S-Latitude" value="' + UserLat[entity_number-1] + '">[-90, 90]<br>\
            Start Longitude: <input type="text" name="S-Longitude" id="S-Longitude" value="' + UserLon[entity_number-1] + '">[-180, 180]<br>\
            Range: <input type="text" name="Range" id="Range">m<br>\
            Bearing: <input type="text" name="Bearing" id="Bearing">Degrees<br>\
            End Latitude: <input type="text" name="E-Latitude" id="E-Latitude" value="' + UserLat[entity_number-2] + '">[-90, 90]<br>\
            End Longitude: <input type="text" name="E-Longitude" id="E-Longitude" value="' + UserLon[entity_number-2] + '">[-180, 180]<br>\
            <div><button class="swap_start_end_line">Swap Start/End</button></div>\
            <div><button class="Making_Line">Fill In</button></div>';
        } else {
            entity.description = '' +
            'Start Latitude: <input type="text" name="S-Latitude" id="S-Latitude" value="' + UserLat[entity_number-1] + '">[-90, 90]<br>\
            Start Longitude: <input type="text" name="S-Longitude" id="S-Longitude" value="' + UserLon[entity_number-1] + '">[-180, 180]<br>\
            Range: <input type="text" name="Range" id="Range">m<br>\
            Bearing: <input type="text" name="Bearing" id="Bearing">Degrees<br>\
            End Latitude: <input type="text" name="E-Latitude" id="E-Latitude">[-90, 90]<br>\
            End Longitude: <input type="text" name="E-Longitude" id="E-Longitude">[-180, 180]<br>\
            <div><button class="swap_start_end_line">Swap Start/End</button></div>\
            <div><button class="Making_Line">Fill In</button></div>';
        }
    }
}


//The 'Lawn Mower' button creates a space-filling pattern
//It works the same as the 'Lines' button, with an additional 3 fields, of which only 2 need to be filled in
function Lawn_Mower_function() {
    //alert("Lawn Mower");
    if (handler != undefined) {
        handler = handler.destroy();
    }
    
    if (handler2 != undefined) {
        handler2 = handler2.destroy();
    }
    
    viewer.canvas.removeEventListener('click', getLatLong_Points);
    viewer.canvas.removeEventListener('click', getLatLong_Polygon);

    //once an entity is selected I can do stuff to it
    if (Cesium.defined(viewer.selectedEntity) && Cesium.defined(viewer.selectedEntity.point)) {
        
        var selected_point = viewer.selectedEntity;
        var selected_point_number = parseInt(selected_point.name.replace(/[^\d.]/g, ''));
        
        //Makes the info box have a text field and a button
	 //There is a series of if else statements that put lat/long data in the text fields
        if (UserLat[selected_point_number] != undefined) {
            
            //getting Range (in meters) so it's easier for the user to estimate the Distance they want
            var positions = Cesium.Cartesian3.fromDegreesArray([UserLon[selected_point_number-1], UserLat[selected_point_number-1], UserLon[selected_point_number], UserLat[selected_point_number]]);
            var surfacePositions = Cesium.PolylinePipeline.generateArc({
                positions: positions
            });

            var scratchCartesian3 = new Cesium.Cartesian3();
            var surfacePositionsLength = surfacePositions.length;
            var Range = 0;
            for (var i = 3; i < surfacePositionsLength; i += 3) {
                scratchCartesian3.x = surfacePositions[i] - surfacePositions[i - 3];
                scratchCartesian3.y = surfacePositions[i + 1] - surfacePositions[i - 2];
                scratchCartesian3.z = surfacePositions[i + 2] - surfacePositions[i - 1];
                Range += Cesium.Cartesian3.magnitude(scratchCartesian3);
            }
            
	    //WARNING: I haven't figured out why, but bugs occur when you use the .toFix() function to round the decimals
            selected_point.description = '' +
            'Start Latitude: <input type="text" name="S-Latitude" id="S-Latitude" value="' + UserLat[selected_point_number-1] + '">[-90, 90]<br>\
            Start Longitude: <input type="text" name="S-Longitude" id="S-Longitude" value="' + UserLon[selected_point_number-1] + '">[-180, 180]<br>\
            Range: <input type="text" name="Range" id="Range">m<br>\
            Bearing: <input type="text" name="Bearing" id="Bearing">Degrees<br>\
            End Latitude: <input type="text" name="E-Latitude" id="E-Latitude" value="' + UserLat[selected_point_number] + '">[-90, 90]<br>\
            End Longitude: <input type="text" name="E-Longitude" id="E-Longitude" value="' + UserLon[selected_point_number] + '">[-180, 180]<br>\
            <div><button class="swap_start_end_Lawn_Mower">Swap Start/End</button></div>\
            <div><button class="Making_Lawn_Mower">Fill In</button></div>\
            <form action="">\
  		<input type="radio" name="handed" id="left" value="left"> Left-handed\
  		<input type="radio" name="handed" id="right" value="right"> Right-handed<br>\
            </form>\
            Number of Lines: <input type="text" name="Number" id="Number"><br>\
            Spacing: <input type="text" name="Spacing" id="Spacing">m<br>\
            Width: <input type="text" name="Width" id="Width" value="' + Range + '">m<br>';

        } else if (UserLat[selected_point_number] == undefined && UserLat[selected_point_number-2] != undefined) {
            
            //getting Range (in meters)
            var positions = Cesium.Cartesian3.fromDegreesArray([UserLon[selected_point_number-1], UserLat[selected_point_number-1], UserLon[selected_point_number-2], UserLat[selected_point_number-2]]);
            var surfacePositions = Cesium.PolylinePipeline.generateArc({
                positions: positions
            });

            var scratchCartesian3 = new Cesium.Cartesian3();
            var surfacePositionsLength = surfacePositions.length;
            var Range = 0;
            for (var i = 3; i < surfacePositionsLength; i += 3) {
                scratchCartesian3.x = surfacePositions[i] - surfacePositions[i - 3];
                scratchCartesian3.y = surfacePositions[i + 1] - surfacePositions[i - 2];
                scratchCartesian3.z = surfacePositions[i + 2] - surfacePositions[i - 1];
                Range += Cesium.Cartesian3.magnitude(scratchCartesian3);
            }
            
            selected_point.description = '' +
            'Start Latitude: <input type="text" name="S-Latitude" id="S-Latitude" value="' + UserLat[selected_point_number-1] + '">[-90, 90]<br>\
            Start Longitude: <input type="text" name="S-Longitude" id="S-Longitude" value="' + UserLon[selected_point_number-1] + '">[-180, 180]<br>\
            Range: <input type="text" name="Range" id="Range">m<br>\
            Bearing: <input type="text" name="Bearing" id="Bearing">Degrees<br>\
            End Latitude: <input type="text" name="E-Latitude" id="E-Latitude" value="' + UserLat[selected_point_number-2] + '">[-90, 90]<br>\
            End Longitude: <input type="text" name="E-Longitude" id="E-Longitude" value="' + UserLon[selected_point_number-2] + '">[-180, 180]<br>\
            <div><button class="swap_start_end_Lawn_Mower">Swap Start/End</button></div>\
            <div><button class="Making_Lawn_Mower">Fill In</button></div>\
            <form action="">\
  		<input type="radio" name="handed" id="left" value="left"> Left-handed\
  		<input type="radio" name="handed" id="right" value="right"> Right-handed<br>\
            </form>\
            Number of Lines: <input type="text" name="Number" id="Number"><br>\
            Spacing: <input type="text" name="Spacing" id="Spacing">m<br>\
            Width: <input type="text" name="Width" id="Width" value="' + Range + '">m<br>';

        } else {
            selected_point.description = '' +
            'Start Latitude: <input type="text" name="S-Latitude" id="S-Latitude" value="' + UserLat[selected_point_number-1] + '">[-90, 90]<br>\
            Start Longitude: <input type="text" name="S-Longitude" id="S-Longitude" value="' + UserLon[selected_point_number-1] + '">[-180, 180]<br>\
            Range: <input type="text" name="Range" id="Range">m<br>\
            Bearing: <input type="text" name="Bearing" id="Bearing">Degrees<br>\
            End Latitude: <input type="text" name="E-Latitude" id="E-Latitude">[-90, 90]<br>\
            End Longitude: <input type="text" name="E-Longitude" id="E-Longitude">[-180, 180]<br>\
            <div><button class="swap_start_end_Lawn_Mower">Swap Start/End</button></div>\
            <div><button class="Making_Lawn_Mower">Fill In</button></div>\
            <form action="">\
  		<input type="radio" name="handed" id="left" value="left"> Left-handed\
  		<input type="radio" name="handed" id="right" value="right"> Right-handed<br>\
            </form>\
            Number of Lines: <input type="text" name="Number" id="Number">m<br>\
            Spacing: <input type="text" name="Spacing" id="Spacing"><br>\
            Width: <input type="text" name="Width" id="Width">m<br>';
        }
    }

}



//The 'Move' button allows you to move either a selected point or polyline created by the 'Lawn Mower' button
//Adding moving a line created by the 'Lines' button could be added later
function Move_function() {
    //alert("Move");
    
    if (handler != undefined) {
        handler = handler.destroy();
    }
    
    if (handler2 != undefined) {
        handler2 = handler2.destroy();
    }

    viewer.canvas.removeEventListener('click', getLatLong_Points);
    viewer.canvas.removeEventListener('click', getLatLong_Polygon);

    var dragging;
    handler2 = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
    
    if (Cesium.defined(viewer.selectedEntity) && Cesium.defined(viewer.selectedEntity.point)) {
        var point = viewer.selectedEntity;
        
        var point_name = point.name;
        var point_number = parseInt(point_name.replace(/[^\d.]/g, ''));
        
        var lat = UserLat[point_number-1];
        var long = UserLon[point_number-1];
        
        point.position = new Cesium.CallbackProperty(function() {
                            return Cesium.Cartesian3.fromDegrees(long, lat);
                        }, false);

        handler2.setInputAction(function(click) {
            var pickedObject = viewer.scene.pick(click.position);
            if (Cesium.defined(pickedObject) && pickedObject.id === point) {
                dragging = pickedObject;
                viewer.scene.screenSpaceCameraController.enableRotate = false;
            }
        }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

        handler2.setInputAction(function() {
            if (Cesium.defined(dragging)) {
                dragging = undefined;
                viewer.scene.screenSpaceCameraController.enableRotate = true;
            }
        }, Cesium.ScreenSpaceEventType.LEFT_UP);

        handler2.setInputAction(function(movement) {
            var position = viewer.camera.pickEllipsoid(movement.endPosition);
            if (!Cesium.defined(position) || !dragging) {
                return;
            }

            var positionCartographic = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
            
            lat = Cesium.Math.toDegrees(positionCartographic.latitude);
            long = Cesium.Math.toDegrees(positionCartographic.longitude);
            UserLat[point_number-1] = lat;
            UserLon[point_number-1] = long;
            point.description = lat + ', ' + long;
            point.position = Cesium.Cartesian3.fromDegrees(long, lat);
        }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

    } else if (Cesium.defined(viewer.selectedEntity) && Cesium.defined(viewer.selectedEntity.polyline)) {
        
        var polyline = viewer.selectedEntity;
        
        var polyline_name = polyline.name;
        var polyline_number = parseInt(polyline_name.replace(/[^\d.]/g, ''));

        var polyArray = UserPolylines[polyline_number-1];
        //alert(polyArray);
        //var polyArray = [0, 0, 10, 0, 10, 10, 20, 10];
        
        var mousePosition = new Cesium.Cartesian2();
        var mousePositionProperty = new Cesium.CallbackProperty(function(time, result){
            var position = scene.camera.pickEllipsoid(mousePosition, undefined, result);
            var cartographic = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
            cartographic.height = 300000.0;
            return Cesium.Ellipsoid.WGS84.cartographicToCartesian(cartographic);
        }, false);
        
        var scene = viewer.scene;  
        var dragging = false;
        handler2 = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
        handler2.setInputAction(function(click) {
            var pickedObject = scene.pick(click.position);
            if (Cesium.defined(pickedObject) && (pickedObject.id === polyline)) {
                dragging = true;
                scene.screenSpaceCameraController.enableRotate = false;
                Cesium.Cartesian2.clone(click.position, mousePosition);

                var ellipsoid = viewer.scene.globe.ellipsoid;
                var cartesian = viewer.camera.pickEllipsoid(mousePosition, ellipsoid);
                var long;
                var lat;
                if (cartesian) {
                    var cartographic = ellipsoid.cartesianToCartographic(cartesian);
                    long = Cesium.Math.toDegrees(cartographic.longitude) - polyArray[0];
                    lat = Cesium.Math.toDegrees(cartographic.latitude) - polyArray[1];
                }

                var combinedArray = [];
                for (var i=0; i < polyArray.length; i+=2) {
                    combinedArray.push(long + polyArray[i]);
                    combinedArray.push(lat + polyArray[i+1]);
                }
                
                polyline.polyline.positions = Cesium.Cartesian3.fromDegreesArray(combinedArray);
            }
        }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
        
        handler2.setInputAction(function(movement) {
            if (dragging) {
                Cesium.Cartesian2.clone(movement.endPosition, mousePosition);
                var ellipsoid = viewer.scene.globe.ellipsoid;
                var cartesian = viewer.camera.pickEllipsoid(mousePosition, ellipsoid);
                var long;
                var lat;
                if (cartesian) {
                    var cartographic = ellipsoid.cartesianToCartographic(cartesian);
                    long = Cesium.Math.toDegrees(cartographic.longitude) - polyArray[0];
                    lat = Cesium.Math.toDegrees(cartographic.latitude) - polyArray[1];
                }

                var combinedArray = [];
                for (var i=0; i < polyArray.length; i+=2) {
                    combinedArray.push(long + polyArray[i]);
                    combinedArray.push(lat + polyArray[i+1]);
                }

                polyline.polyline.positions = Cesium.Cartesian3.fromDegreesArray(combinedArray);
            }
        }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
        
        handler2.setInputAction(function(click) {
            if(dragging) {
              dragging = false;
              scene.screenSpaceCameraController.enableRotate = true;
              polyline.polyline.positions = scene.camera.pickEllipsoid(click.position);
            }
        }, Cesium.ScreenSpaceEventType.LEFT_UP);
        
    }

}


//the 'Delete' button deletes a selected entity
function Delete_function() {
    //alert("Delete");
    if (handler != undefined) {
        handler = handler.destroy();
    }

    if (handler2 != undefined) {
        handler2 = handler2.destroy();
    }


    viewer.canvas.removeEventListener('click', getLatLong_Points);
    viewer.canvas.removeEventListener('click', getLatLong_Polygon);
    
    viewer.entities.remove(viewer.selectedEntity);
}


//The 'Delete All' button deletes all entities in Cesium
function Delete_All_function() {
    //alert("Delete All");
    if (handler != undefined) {
        handler = handler.destroy();
    }

    if (handler2 != undefined) {
        handler2 = handler2.destroy();
    }

    viewer.canvas.removeEventListener('click', getLatLong_Points);
    viewer.canvas.removeEventListener('click', getLatLong_Polygon);
    
    viewer.entities.removeAll();
    
    numClicks = 0;
    UserLat = [];
    UserLon = [];
}


//The 'Export Coordinates' button exports the coordinates to a downloadable textfile with the coordinates in Latitude/Longitude, UTM, and Modified UTM
function Export_function() {
    //alert("Export");
    if (handler != undefined) {
        handler = handler.destroy();
    }

    viewer.canvas.removeEventListener('click', getLatLong_Points);
    viewer.canvas.removeEventListener('click', getLatLong_Polygon);
    
    download(AllPointsOutString(UserLat, UserLon, UserLines, UserPolylines), 'Coordinates.txt', 'text/plain');
    download(hypackOutString(UserLat, UserLon, UserLines, UserPolylines, Order), 'HYPACK.L84', 'text/plain');
}